{
  "problems": {
    "l1_c1_p1": {
      "description": "Move all even integers to the back of the linked list, preserving relative order of odds and evens.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "evens_tc_01",
          "input": "1,2,3,4,5",
          "expected_output": "1,3,5,2,4",
          "fail_node_id": "l1_c1_p1_node_evens_basic"
        },
        {
          "id": "evens_tc_02",
          "input": "2,4,6",
          "expected_output": "2,4,6",
          "fail_node_id": "l1_c1_p1_node_evens_all_even"
        },
        {
          "id": "evens_tc_03",
          "input": "1,3,5",
          "expected_output": "1,3,5",
          "fail_node_id": "l1_c1_p1_node_evens_all_odd"
        },
        {
          "id": "evens_tc_04",
          "input": "2,1,4,3,6,5",
          "expected_output": "1,3,5,2,4,6",
          "fail_node_id": "l1_c1_p1_node_evens_stability"
        },
        {
          "id": "evens_tc_05_even_head",
          "input": "2,1,3,5",
          "expected_output": "1,3,5,2",
          "fail_node_id": "l1_c1_p1_node_evens_head_update"
        },
        {
          "id": "evens_tc_06_even_tail",
          "input": "1,3,5,2",
          "expected_output": "1,3,5,2",
          "fail_node_id": "l1_c1_p1_node_evens_tail_handling"
        },
        {
          "id": "evens_tc_08_single_even",
          "input": "2",
          "expected_output": "2",
          "fail_node_id": "l1_c1_p1_node_evens_single_element"
        }
      ]
    },
    "l1_c1_p2": {
      "description": "Move the node with the maximum value to the front of the linked list.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "max_tc_01",
          "input": "1,2,3,4,5",
          "expected_output": "5,1,2,3,4",
          "fail_node_id": "l1_c1_p2_node_max_not_front"
        }
      ]
    },
    "l1_c2_p1": {
      "description": "Remove duplicates from a sorted linked list so that each value appears only once.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "dup_tc_01",
          "input": "1,1,2,3,3,3",
          "expected_output": "1,2,3",
          "fail_node_id": "l1_c2_p1_node_duplicates_basic"
        },
        {
          "id": "dup_tc_02",
          "input": "1,2,3,4",
          "expected_output": "1,2,3,4",
          "fail_node_id": "l1_c2_p1_node_no_duplicates"
        },
        {
          "id": "dup_tc_03",
          "input": "2,2,2,2",
          "expected_output": "2",
          "fail_node_id": "l1_c2_p1_node_duplicates_all_same"
        },
        {
          "id": "dup_tc_04",
          "input": "1,1,1,2,2,3,3,3,3",
          "expected_output": "1,2,3",
          "fail_node_id": "l1_c2_p1_node_duplicates_multiple_blocks"
        }
      ]
    },
    "l1_c3_p1": {
      "description": "Identify the 5 bugs (2 syntax, 3 logical) in the linked-list door unlocking code.",
      "type": "scroll_bug_finder",
      "bug_targets": [
        {
          "id": "bug_last_node_assignment",
          "concept_node_id": "l1_c3_p1_node_circ_last_next_assignment"
        },
        {
          "id": "bug_erroneous_return_statement",
          "concept_node_id": "l1_c3_p1_node_erroneous_return_statement"
        },
        {
          "id": "bug_half_unlock_missing_arg",
          "concept_node_id": "l1_c3_p1_node_func_call_missing_arguments"
        },
        {
          "id": "bug_bptr_uses_a_index",
          "concept_node_id": "l1_c3_p1_node_wrong_variable_bptr"
        },
        {
          "id": "bug_main_guard_usage",
          "concept_node_id": "l1_c3_p1_node_main_guard_usage"
        }
      ]
    },
    "l1_c4_p1": {
      "description": "Choose Aptr and Bptr on a 10-node circular list so that full_unlock splits the circle into two equal rings.",
      "type": "circle_two_pointers",
      "checker": "circle_two_pointers",
      "params": {
        "n_nodes": 10,
        "correct_aptr_idx": 2,
        "correct_bptr_idx": 7,
        "must_match_order": false
      },
      "error_mapping": {
        "ERR_ADJACENT": "l1_c4_p1_node_circle_adjacent",
        "ERR_WRONG_DISTANCE": "l1_c4_p1_node_circle_wrong_distance",
        "ERR_WRONG_ORDER": "l1_c4_p1_node_circle_swapped",
        "ERR_OPPOSITE_WRONG_PAIR": "l1_c4_p1_node_circle_opposite_wrong_pair"
      }
    },
    "l2_c1_p1": {
      "type": "puzzle",
      "expression": "x = a + b * c % d >> e"
    },
    "l2_c1_p2": {
      "description": "Convert the prefix expression '= y && << a b >> c + d e' into a correct infix expression.",
      "type": "puzzle"
    },
    "l2_c1_p3": {
      "description": "Convert the postfix expression 'x a b c * d % + e >> =' into a correct prefix expression.",
      "type": "puzzle"
    },
    "l2_c2_p1": {
      "description": "Reverse all items in the stack using only queue operations. You may only push and pop from the top of the stack, and enqueue/dequeue from the ends of the queue.",
      "type": "puzzle"
    },
    "l2_c2_p2": {
      "description": "Reorder the first k items of the queue using the stack so that those k items are restored to the correct order, while the remaining items stay in their original positions.",
      "type": "puzzle"
    },
    "l2_c2_p3": {
      "description": "Sort a stack in ascending order using only push/pop operations and one temporary stack.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "sortstack_tc_01_basic",
          "input": "3,1,4,2",
          "expected_output": "1,2,3,4",
          "fail_node_id": "l2_c2_p3_node_sortstack_basic"
        },
        {
          "id": "sortstack_tc_02_already_sorted",
          "input": "1,2,3,4",
          "expected_output": "1,2,3,4",
          "fail_node_id": "l2_c2_p3_node_sortstack_already_sorted"
        },
        {
          "id": "sortstack_tc_03_reverse_sorted",
          "input": "4,3,2,1",
          "expected_output": "1,2,3,4",
          "fail_node_id": "l2_c2_p3_node_sortstack_reverse_sorted"
        },
        {
          "id": "sortstack_tc_04_with_duplicates",
          "input": "3,1,2,1,3",
          "expected_output": "1,1,2,3,3",
          "fail_node_id": "l2_c2_p3_node_sortstack_duplicates"
        },
        {
          "id": "sortstack_tc_05_single",
          "input": "7",
          "expected_output": "7",
          "fail_node_id": "l2_c2_p3_node_sortstack_single"
        },

        {
          "id": "sortstack_tc_06_tutorial_example",
          "input": "6,5,4,3,2,1",
          "expected_output": "1,2,3,4,5,6",
          "fail_node_id": "l2_c2_p3_node_sortstack_reverse_sorted"
        }
      ]
    },
    "l3_c1_p1": {
      "description": "Click the binary tree nodes in the correct In-order traversal sequence. A wrong click resets the puzzle.",
      "type": "puzzle"
    },
    "l3_c1_p2": {
      "description": "Click the binary tree nodes in the correct Pre-order traversal sequence. A wrong click resets the puzzle.",
      "type": "puzzle"
    },
    "l3_c1_p3": {
      "description": "Construct the binary tree using the given Pre-order and In-order traversal sequences.",
      "type": "puzzle"
    },
    "l3_c2_p1": {
      "description": "Find the maximum depth of a Binary Tree and return it.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "maxdepth_tc_02_single",
          "input": "1-N",
          "expected_output": "0",
          "fail_node_id": "l3_c2_p1_node_maxdepth_single_node"
        },
        {
          "id": "maxdepth_tc_03_two_levels",
          "input": "1,2,3-N,L,R",
          "expected_output": "1",
          "fail_node_id": "l3_c2_p1_node_maxdepth_basic_height"
        },
        {
          "id": "maxdepth_tc_04_left_skewed",
          "input": "1,2,3,4-N,L,LL,LLL",
          "expected_output": "3",
          "fail_node_id": "l3_c2_p1_node_maxdepth_skewed_left"
        },
        {
          "id": "maxdepth_tc_05_right_skewed",
          "input": "1,2,3,4-N,R,RR,RRR",
          "expected_output": "3",
          "fail_node_id": "l3_c2_p1_node_maxdepth_skewed_right"
        },
        {
          "id": "maxdepth_tc_06_unbalanced_deeper_left",
          "input": "1,2,3,4,5-N,L,R,LL,LLL",
          "expected_output": "3",
          "fail_node_id": "l3_c2_p1_node_maxdepth_unbalanced_tree"
        },
        {
          "id": "maxdepth_tc_07_sparse_with_nulls",
          "input": "1,2,3,4,5-N,L,R,LR,RL",
          "expected_output": "2",
          "fail_node_id": "l3_c2_p1_node_maxdepth_null_children_handling"
        },
        {
          "id": "maxdepth_tc_08_complete_three_levels",
          "input": "1,2,3,4,5,6,7-N,L,R,LL,LR,RL,RR",
          "expected_output": "2",
          "fail_node_id": "l3_c2_p1_node_maxdepth_complete_tree"
        },
        {
          "id": "maxdepth_tc_09_zigzag_chain",
          "input": "1,2,3,4,5-N,L,LR,LRL,LRLR",
          "expected_output": "4",
          "fail_node_id": "l3_c2_p1_node_maxdepth_zigzag_structure"
        },
        {
          "id": "maxdepth_tc_10_tutorial_example",
          "input": "50,20,60,10,30,55,80-N,L,R,LL,LR,LRL,RR",
          "expected_output": "3",
          "fail_node_id": "l3_c2_p1_node_maxdepth_basic_height"
        }
      ]
    },
    "l3_c2_p2": {
      "type": "puzzle",
      "description": "Perform level-order traversal (Breadth-First Search) on the binary tree using a queue. Use the buttons to dequeue into cur, print cur.item, and enqueue cur's children to match the expected output."
    },
    "l3_c2_p3": {
      "type": "puzzle",
      "description": "Search for a target value in a Binary Search Tree by deciding whether to move to the left or right child at each step."
    },
    "l4_c1_p1_q1": {
      "description": "Given L = [8,4,5] and Relics = [1,2,6,9,4,3], how many item comparisons of the form (Q.item == X) are made by subset(L, Relics)?",
      "type": "scroll_mcq",
      "correct_answer": "17",
      "option_to_concept_node": {
        "10": "l4_c1_p1_q1_node_counts_only_successful_searches",
        "6": "l4_c1_p1_q1_node_stops_after_first_found_instead_of_scan",
        "3": "l4_c1_p1_q1_node_counts_only_elements_in_L"
      }
    },
    "l4_c1_p1_q2": {
      "description": "Let R denote the Relics list. Based on the subset(L, R) and element(X, Q) code, when will the worst case happen?",
      "type": "scroll_mcq",
      "correct_answer": "opt3",
      "option_to_concept_node": {
        "opt1": "l4_c1_p1_q2_node_wrong_thinks_missing_early_is_worst",
        "opt2": "l4_c1_p1_q2_node_wrong_ignores_final_failed_search_cost",
        "opt4": "l4_c1_p1_q2_node_wrong_thinks_all_present_at_end_is_worst"
      }
    },
    "l4_c1_p1_q3": {
      "description": "Let O denote the Observed list and R denote the Relics list. Using the given subset(O, R) and element(X, Q) code, what is the worst-case running time of subset as a function of |O| and |R|?",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "l4_c1_p1_q3_node_focuses_only_on_R",
        "opt2": "l4_c1_p1_q3_node_focuses_only_on_O",
        "opt3": "l4_c1_p1_q3_node_adds_instead_of_multiplies"
      }
    },
    "l4_c1_p2_q1": {
      "description": "Documents are sealed according to the function Sealer(N) below. How many times is Seal() called when N = 8?",
      "type": "scroll_mcq",
      "correct_answer": "8",
      "option_to_concept_node": {
        "6": "l4_c1_p2_q1_node_counts_outer_or_off_by_one",
        "12": "l4_c1_p2_q1_node_multiplies_incorrectly",
        "15": "l4_c1_p2_q1_node_treats_doubling_as_linear"
      }
    },
    "l4_c1_p2_q2": {
      "description": "In the function Sealer(N), how many iterations does the inner loop (controlled by k) run in terms of N? (log₂ means log base 2.)",
      "type": "scroll_mcq",
      "correct_answer": "opt1",
      "option_to_concept_node": {
        "opt2": "l4_c1_p2_q2_node_missing_plus_one",
        "opt3": "l4_c1_p2_q2_node_log_base_confusion",
        "opt4": "l4_c1_p2_q2_node_forgets_starting_value"
      }
    },
    "l4_c1_p2_q3": {
      "description": "In the function Sealer(N), how many iterations does the outer loop (controlled by j) run in terms of N? (log₃ means log base 3.)",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "l4_c1_p2_q3_node_base_confusion_log2",
        "opt2": "l4_c1_p2_q3_node_unspecified_log_base",
        "opt3": "l4_c1_p2_q3_node_missing_plus_one"
      }
    },
    "l4_c1_p2_q4": {
      "description": "For Sealer(N), determine the time complexity in Big-O notation in terms of N. (Hint: the inner loop runs log₂(N) times and the outer loop runs log₃(N) times.)",
      "type": "scroll_mcq",
      "correct_answer": "opt3",
      "option_to_concept_node": {
        "opt1": "l4_c1_p2_q4_node_assumes_linear_growth",
        "opt2": "l4_c1_p2_q4_node_collapses_nested_logs",
        "opt4": "l4_c1_p2_q4_node_confuses_log_squared_identity"
      }
    },
    "l4_c1_p3_q1": {
      "description": "Given the recursive function Book(N), how many times is Read() executed when starting with N = 3?",
      "type": "scroll_mcq",
      "correct_answer": "11",
      "option_to_concept_node": {
        "7": "l4_c1_p3_q1_node_counts_only_first_call",
        "13": "l4_c1_p3_q1_node_overcounts_recursive_levels",
        "14": "l4_c1_p3_q1_node_ignores_work_per_call"
      }
    },
    "l4_c1_p3_q2": {
      "description": "Let W(N) denote the number of Read() calls in Book(N). Which recurrence correctly represents W(N)?",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "l4_c1_p3_q2_node_misses_second_recursive_call",
        "opt2": "l4_c1_p3_q2_node_not_fibonacci_structure",
        "opt3": "l4_c1_p3_q2_node_missing_linear_term"
      }
    },
    "l4_c1_p3_q3": {
      "description": "For the recursive function Book(N), what is the time complexity in Big-O notation?",
      "type": "scroll_mcq",
      "correct_answer": "opt1",
      "option_to_concept_node": {
        "opt2": "l4_c1_p3_q3_node_quadratic_misinterpretation",
        "opt3": "l4_c1_p3_q3_node_linear_misinterpretation",
        "opt4": "l4_c1_p3_q3_node_factorial_misinterpretation"
      }
    },
    "l4_c1_p4": {
      "description": "Find the minimal element in a cyclically (rotated) sorted sequence in O(log n) time. m and n are the indices of the first and last elements respectively.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "min_tc_01_sorted_no_rotation",
          "input": "1,2,3,4,5",
          "expected_output": "1",
          "fail_node_id": "l4_c1_p4_node_already_sorted_segment"
        },
        {
          "id": "min_tc_02_simple_rotation",
          "input": "4,5,1,2,3",
          "expected_output": "1",
          "fail_node_id": "l4_c1_p4_node_rotation_binary_search"
        },
        {
          "id": "min_tc_03_single_element",
          "input": "7",
          "expected_output": "7",
          "fail_node_id": "l4_c1_p4_node_single_element"
        },
        {
          "id": "min_tc_04_two_elements_rotated",
          "input": "2,1",
          "expected_output": "1",
          "fail_node_id": "l4_c1_p4_node_two_element_boundary"
        },
        {
          "id": "min_tc_05_rotation_compare_boundary",
          "input": "3,4,5,1,2",
          "expected_output": "1",
          "fail_node_id": "l4_c1_p4_node_compare_wrong_boundary"
        }
      ]
    },
    "l5_c1_p1": {
      "type": "puzzle",
      "description": "Return the books to the correct shelves so that each row’s load factor matches its target. Load factor is α = n / m, where n is the number of books in the row and m is the number of shelves in the row."
    },
    "l5_c1_p2_best": {
      "type": "puzzle",
      "description": "Arrange the books into the hash table (open addressing with linear probing) to represent the best-case scenario: no collisions and no probing."
    },
    "l5_c1_p2_worst": {
      "type": "puzzle",
      "description": "Drag and drop books (keys) into the highlighted shelf row to create the required hash table scenario under Open Addressing + Linear Probing. Colors are randomized; only the letter (key) matters. Hover 'Evaluate' to see which row is graded. After arranging correctly, answer 1 MCQ about the average insertion cost at load factor 0.5."
    },
    "l5_c3_p1": {
      "type": "puzzle",
      "description": "Find the 4-character string that maps to 1779 in base 8."
    },
    "l5_c3_p2": {
      "type": "puzzle",
      "description": "Given the strings 'ABC', 'CAB', and 'BAC', compute their hash values using base r = 2^p (p=3) and h(k) = k mod (2^p - 1)."
    },

    "l6_c1_p1": {
      "type": "puzzle",
      "description": "Read the trie and input the words that exist in it by dragging and dropping the correct words onto the device."
    },
    "l6_c3_p1": {
      "description": "Given a Trie and a prefix, return all words in the Trie that start with the given prefix in alphabetical order.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "trie_prefix_tc_01",
          "input": "kit,kitten,kin,keep-ki",
          "expected_output": "kin,kit,kitten",
          "fail_node_id": "l6_c3_p1_node_trie_prefix_core"
        },
        {
          "id": "trie_prefix_tc_02",
          "input": "cat,car,carbon,dog-ca",
          "expected_output": "car,carbon,cat",
          "fail_node_id": "l6_c3_p1_node_trie_prefix_alphabetical"
        },
        {
          "id": "trie_prefix_tc_03",
          "input": "apple,banana,cherry-do",
          "expected_output": "empty!",
          "fail_node_id": "l6_c3_p1_node_trie_prefix_not_found"
        },
        {
          "id": "trie_prefix_tc_04",
          "input": "a,app,apple,apply-app",
          "expected_output": "app,apple,apply",
          "fail_node_id": "l6_c3_p1_node_trie_prefix_word_vs_prefix"
        },
        {
          "id": "trie_prefix_tc_05",
          "input": "bat,ball,bark-ba",
          "expected_output": "ball,bark,bat",
          "fail_node_id": "l6_c3_p1_node_trie_prefix_sibling_traversal"
        }
      ]
    }
  },
  "concepts": {
    "concept_ll": {
      "label": "Linked Lists",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_ll_singly": {
      "label": "Singly Linked List",
      "parent_id": "concept_ll",
      "prerequisites": ["concept_ll"],
      "generic_hint": "A singly linked list is a linear sequence of nodes; each node stores data and a reference (pointer) to the next node, ending with None."
    },
    "concept_ll_node_structure": {
      "label": "Node Structure (data, next)",
      "parent_id": "concept_ll_singly",
      "prerequisites": ["concept_ll_singly"],
      "generic_hint": "Each node stores the element (data) and a link to the next node. If you change links, do it carefully so you don't lose access to the rest of the list."
    },
    "concept_ll_head_pointer": {
      "label": "Head Pointer",
      "parent_id": "concept_ll_singly",
      "prerequisites": ["concept_ll_node_structure", "concept_ll_singly"],
      "generic_hint": "The head node is essential to locate the first node in the list. If the first node changes, you must update the head reference."
    },
    "concept_ll_operations": {
      "label": "Key Operations (Traversal, Search, Insert, Delete)",
      "parent_id": "concept_ll",
      "prerequisites": ["concept_ll_node_structure", "concept_ll_head_pointer"],
      "generic_hint": "Most linked list operations rely on traversal: walking node-by-node using next until you find what you need (or reach None)."
    },
    "concept_ll_traversal": {
      "label": "Traversal through nodes in a Linked List",
      "parent_id": "concept_ll_operations",
      "prerequisites": ["concept_ll_head_pointer", "concept_ll_node_structure"],
      "generic_hint": "To process a linked list, start from head and repeatedly move current = current.next until current is None or until you find a node with a different value if you are removing duplicates."
    },
    "concept_ll_pointer_updates": {
      "label": "Pointer Updates (Relinking)",
      "parent_id": "concept_ll_operations",
      "prerequisites": [
        "concept_ll_pointer_manipulation",
        "concept_ll_traversal",
        "concept_ll_node_structure"
      ],
      "generic_hint": "When rearranging nodes, update next pointers in a safe order so you never lose the remaining chain and you don't accidentally create cycles."
    },
    "concept_ll_insert_node": {
      "label": "Insert a Node (at head, tail, or middle)",
      "parent_id": "concept_ll_operations",
      "prerequisites": [
        "concept_ll_traversal",
        "concept_ll_pointer_updates",
        "concept_ll_node_structure"
      ],
      "generic_hint": "To insert, first point the new node's 'next' to the succeeding node, then update the previous node's 'next' to point to the new node. Order matters to avoid losing the rest of the list!"
    },
    "concept_ll_delete_node": {
      "label": "Delete a Node (by relinking next pointers)",
      "parent_id": "concept_ll_operations",
      "prerequisites": ["concept_ll_pointer_updates", "concept_ll_traversal"],
      "generic_hint": "To remove a node in a linked list, you don't 'shift' elements—update links so the previous node points to the node after the removed one."
    },
    "concept_ll_search_findat": {
      "label": "Search Node (findAt)",
      "parent_id": "concept_ll_traversal_logic",
      "prerequisites": ["concept_ll_traversal_logic"],
      "generic_hint": "Given an index i, traverse the list i times to return the pointer to that specific node."
    },
    "concept_ll_size": {
      "label": "Size of LinkedList",
      "parent_id": "concept_ll_operations",
      "prerequisites": ["concept_ll_traversal_logic"],
      "generic_hint": "You can count nodes manually via traversal or maintain a dedicated 'size' attribute in the class."
    },
    "concept_ll_pointer_manipulation": {
      "label": "Pointer Manipulation",
      "parent_id": "concept_ll",
      "prerequisites": [
        "concept_ll_node_structure",
        "concept_ll_traversal",
        "concept_ll_operations",
        "concept_ll_pointer_updates"
      ],
      "generic_hint": "Whenever you change links, update next pointers carefully so you never lose access to the remaining nodes."
    },
    "concept_ll_head_pointer_update": {
      "label": "Head Pointer Update",
      "parent_id": "concept_ll_pointer_manipulation",
      "prerequisites": [
        "concept_ll_head_pointer",
        "concept_ll_pointer_manipulation"
      ],
      "generic_hint": "If the first node of the list changes (e.g., original head is moved away), you must update ll.head to point to the new first node."
    },
    "concept_ll_reordering": {
      "label": "Linked List Reordering",
      "parent_id": "concept_ll",
      "prerequisites": [
        "concept_ll_head_pointer",
        "concept_ll_node_structure",
        "concept_ll_traversal",
        "concept_ll_pointer_updates"
      ],
      "generic_hint": "When rearranging a linked list, you should relink existing nodes without losing any nodes, creating cycles, or breaking the chain."
    },
    "concept_ll_stable_partition": {
      "label": "Stable Partition",
      "parent_id": "concept_ll_reordering",
      "prerequisites": [
        "concept_ll_reordering",
        "concept_ll_traversal",
        "concept_ll_pointer_updates"
      ],
      "generic_hint": "A stable partition keeps the relative order within each group. Remember to keep odds in original order, then evens in original order after all the odds."
    },
    "concept_ll_tail_pointer_handling": {
      "label": "Tail Pointer Handling",
      "parent_id": "concept_ll_pointer_manipulation",
      "prerequisites": [
        "concept_ll_pointer_manipulation",
        "concept_ll_traversal",
        "concept_ll_node_structure"
      ],
      "generic_hint": "After reordering, ensure the last node’s next is None and the tail is correctly linked so no nodes are dropped or cycles formed."
    },
    "concept_ll_single_node_handling": {
      "label": "Single Node Handling (Edge Case)",
      "parent_id": "concept_ll_edge_cases",
      "prerequisites": ["concept_ll_head_pointer", "concept_ll_node_structure"],
      "generic_hint": "A list with only one node is a common edge case. Ensure your logic doesn't crash by trying to access '.next' on a None object or a non-existent second node."
    },
    "concept_ll_edge_cases": {
      "label": "Edge Cases",
      "parent_id": "concept_ll",
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_ll_all_even": {
      "label": "All Even Case",
      "parent_id": "concept_ll_edge_cases",
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_ll_all_odd": {
      "label": "All Odd Case",
      "parent_id": "concept_ll_edge_cases",
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_ll_edge_case_no_change": {
      "label": "No-Change Cases (already satisfied / all equal)",
      "parent_id": "concept_ll_edge_cases",
      "prerequisites": [],
      "generic_hint": "If the operation does not require any movement (e.g., max already at head, or all values equal), the list should remain unchanged and still valid."
    },
    "concept_ll_sorted_consecutive_duplicates": {
      "label": "Sorted List Property: Consecutive Duplicates",
      "parent_id": "concept_ll_traversal",
      "generic_hint": "Because the list is sorted, duplicates appear consecutively. While traversing, compare current with current.next; if equal, delete the next node (current.next = current.next.next) and check again."
    },
    "concept_ll_collapse_to_single_node": {
      "label": "All Same Values → Single Node",
      "parent_id": "concept_ll_edge_cases",
      "prerequisites": ["concept_ll_sorted_consecutive_duplicates"],
      "generic_hint": "If all nodes contain the same value, keep the first node and delete every subsequent node by relinking next pointers until only one node remains."
    },
    "concept_ll_circular_link_assignment": {
      "label": "Circular Linked List: Last Node Linking",
      "parent_id": "concept_ll",
      "prerequisites": [
        "concept_ll_node_structure",
        "concept_ll_traversal",
        "concept_ll_pointer_manipulation"
      ],
      "generic_hint": "In a circular linked list, the last node's next pointer must reference the head node. Use assignment operator (=) to update links; comparison operator (==) does not change pointers."
    },
    "concept_function_return_value": {
      "label": "Return Value (Function Output)",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "Functions must return the correct variable as specified. In linked list problems, this is often the head node after modification."
    },
    "concept_function_parameters_arguments": {
      "label": "Function Definition vs Function Call",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "The number of arguments in a function call must match the number of parameters in its definition."
    },
    "concept_variable_usage_logic": {
      "label": "Variable Usage and Logical Consistency",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "Ensure each variable represents what it is intended to represent. Using the wrong variable in calculations can cause logical errors."
    },
    "concept_program_execution_environment": {
      "label": "Program Structure and Execution Environment",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_ll_circular": {
      "label": "Circular Linked List",
      "parent_id": "concept_ll",
      "prerequisites": [
        "concept_ll_node_structure",
        "concept_ll_traversal",
        "concept_ll_pointer_manipulation"
      ],
      "generic_hint": "A circular linked list is formed when the last node’s next pointer references the first node instead of None."
    },
    "concept_ll_circular_distance": {
      "label": "Distance in a Circular List",
      "parent_id": "concept_ll_circular",
      "prerequisites": ["concept_ll_circular"],
      "generic_hint": "In a circular list, traversal continues around the ring. The distance between two nodes is the number of steps taken following next pointers."
    },
    "concept_ll_circular_half_split": {
      "label": "Equal Split of Circular List",
      "parent_id": "concept_ll_circular",
      "prerequisites": ["concept_ll_circular"],
      "generic_hint": "To divide a circular list of n nodes into two equal rings, the cut points must be n/2 nodes apart."
    },
    "concept_ll_pointer_reassignment_circular": {
      "label": "Pointer Reassignment in Circular List",
      "parent_id": "concept_ll_circular",
      "prerequisites": ["concept_ll_circular"],
      "generic_hint": "Reassigning temp.next changes the structure of the ring. In circular lists, a single pointer reassignment can break or form new loops."
    },
    "concept_function_parameter_order": {
      "label": "Function Parameter Order",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "The order of parameters in a function call determines which variable plays which role inside the function."
    },
    "concept_expression_notation": {
      "label": "Expression Processing",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": null
    },
    "concept_infix_notation": {
      "label": "Infix Notation",
      "parent_id": "concept_expression_notation",
      "prerequisites": ["concept_operator_precedence"],
      "generic_hint": "In Infix, the operator is placed between operands (e.g., A + B). Use parentheses or precedence rules (BODMAS) to determine the order of evaluation."
    },
    "concept_prefix_notation": {
      "label": "Prefix Notation",
      "parent_id": "concept_expression_notation",
      "prerequisites": ["concept_operator_precedence"],
      "generic_hint": "In Prefix notation, the operator comes before its operands (e.g., + A B). It is evaluated from right to left or by finding the first operator-operand-operand pattern."
    },

    "concept_postfix_notation": {
      "label": "Postfix Notation",
      "parent_id": "concept_expression_notation",
      "prerequisites": ["concept_operator_precedence"],
      "generic_hint": "In Postfix notation, the operator follows its operands (e.g., A B +). This is the standard format for stack-based evaluation as it eliminates the need for parentheses."
    },
    "concept_infix_to_postfix_general": {
      "label": "Infix to Postfix Conversion",
      "parent_id": "concept_infix_notation",
      "prerequisites": [
        "concept_infix_notation",
        "concept_postfix_notation",
        "concept_operator_precedence"
      ],
      "generic_hint": "In postfix, an operator appears after its operands. While converting from infix, output operands immediately and manage operators using a stack."
    },

    "concept_operator_precedence": {
      "label": "Operator Precedence",
      "parent_id": "concept_expression_notation",
      "prerequisites": ["concept_operator_precedence_table"],
      "generic_hint": "Higher precedence operators must be handled before lower precedence operators."
    },

    "concept_operator_precedence_table": {
      "label": "Operator Precedence Table",
      "parent_id": "concept_operator_precedence",
      "prerequisites": [],
      "generic_hint": "Precedence (high→low): *, /, %  >  +, -  >  <<, >>  >  &&  >  ="
    },

    "concept_assignment_lowest_precedence": {
      "label": "Assignment is Lowest Precedence",
      "parent_id": "concept_operator_precedence",
      "prerequisites": ["concept_operator_precedence_table"],
      "generic_hint": "Treat '=' as lowest precedence: fully convert the RHS first, then apply assignment at the end in postfix."
    },

    "concept_prefix_to_infix_general": {
      "label": "Prefix to Infix Conversion",
      "parent_id": "concept_expression_notation",
      "prerequisites": [
        "concept_prefix_notation",
        "concept_infix_notation",
        "concept_operator_precedence"
      ],
      "generic_hint": "In prefix, operators come before operands. Reconstruct the expression by identifying the outermost operator, building its left and right operands, and adding parentheses to preserve structure."
    },

    "concept_postfix_to_prefix_general": {
      "label": "Postfix to Prefix Conversion",
      "parent_id": "concept_expression_notation",
      "prerequisites": [
        "concept_postfix_notation",
        "concept_prefix_notation",
        "concept_operator_precedence"
      ],
      "generic_hint": "Postfix places operators after operands. Convert using a stack: scan tokens left-to-right, push operands; on an operator, pop right then left, form a prefix fragment (op left right), then push it back."
    },

    "concept_stack_usage_in_postfix_to_prefix": {
      "label": "Stack Usage in Postfix→Prefix",
      "parent_id": "concept_postfix_to_prefix_general",
      "prerequisites": ["concept_postfix_to_prefix_general"],
      "generic_hint": "When you encounter an operator in postfix, pop two expressions: first is the right operand, second is the left operand. Combine as (op left right) and push back."
    },

    "concept_expression_grouping": {
      "label": "Expression Grouping with Subexpressions",
      "parent_id": "concept_expression_notation",
      "prerequisites": [
        "concept_expression_notation",
        "concept_postfix_notation"
      ],
      "generic_hint": "In postfix, whenever you finish processing an operator, you have built a complete subexpression. Treat it as a single unit for later operators."
    },

    "concept_queue": {
      "label": "Queue",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "A queue is a First-In-First-Out (FIFO) structure. Items are added at the rear (enqueue) and removed from the front (dequeue)."
    },
    "concept_stack": {
      "label": "Stack",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "A stack is LIFO. You can only access the top via push and pop."
    },
    "concept_reverse_stack_with_queue_general": {
      "label": "Reverse a Stack Using a Queue",
      "parent_id": "concept_stack",
      "prerequisites": ["concept_queue", "concept_stack"],
      "generic_hint": "To reverse a stack with a queue, transfer all items from stack to queue, then transfer all items from queue back to stack. The FIFO property of the queue combined with pushing back into the stack reverses the order."
    },
    "concept_queue_order_preservation": {
      "label": "Preserve Queue Order During Transfer",
      "parent_id": "concept_queue",
      "prerequisites": ["concept_queue"],
      "generic_hint": "During reversal, avoid extra rotations or reordering inside the queue. Keep enqueue and dequeue behavior consistent so the queue preserves the correct order for items in between."
    },
    "concept_full_transfer_required": {
      "label": "Full Transfer Requirement",
      "parent_id": "concept_reverse_stack_with_queue_general",
      "prerequisites": [
        "concept_queue",
        "concept_stack",
        "concept_reverse_stack_with_queue_general"
      ],
      "generic_hint": "A complete reversal requires moving all elements out and all elements back. Partial transfers only reverse a prefix and will not produce a fully reversed stack."
    },
    "concept_reverse_first_k_of_queue_with_stack_general": {
      "label": "Reverse First k Items in a Queue Using a Stack",
      "parent_id": "concept_queue",
      "prerequisites": ["concept_queue", "concept_stack"],
      "generic_hint": "To reverse the first k items while keeping the rest in order: move the first k from queue to stack, move them back to queue (reversed), then rotate the remaining n-k items to keep them behind the reversed block."
    },
    "concept_stack_usage_for_first_k": {
      "label": "Use Stack to Reverse a Prefix",
      "parent_id": "concept_reverse_first_k_of_queue_with_stack_general",
      "prerequisites": [
        "concept_stack",
        "concept_reverse_first_k_of_queue_with_stack_general"
      ],
      "generic_hint": "The stack reverses order because it is LIFO. Pushing k dequeued items and then popping them back produces the reversed prefix."
    },

    "concept_queue_segment_preservation": {
      "label": "Preserve Tail Segment (n-k items)",
      "parent_id": "concept_reverse_first_k_of_queue_with_stack_general",
      "prerequisites": [
        "concept_queue",
        "concept_reverse_first_k_of_queue_with_stack_general"
      ],
      "generic_hint": "Only the first k items should be manipulated. The remaining n-k items must stay in the same relative order and end up behind the reversed prefix."
    },

    "concept_queue_rotation_timing": {
      "label": "Queue Rotation Timing",
      "parent_id": "concept_reverse_first_k_of_queue_with_stack_general",
      "prerequisites": [
        "concept_queue",
        "concept_reverse_first_k_of_queue_with_stack_general"
      ],
      "generic_hint": "Rotation (dequeue then enqueue) is used after reversing the first k items to move the untouched tail segment behind the reversed block."
    },

    "concept_stack_operations": {
      "label": "Stack Operations (push/pop)",
      "parent_id": "concept_stack",
      "prerequisites": ["concept_stack"],
      "generic_hint": "push adds to the top; pop removes from the top. Under this tutorial constraint, you should not access elements by index."
    },

    "concept_stack_sort": {
      "label": "Sorting a Stack Using Another Stack",
      "parent_id": "concept_stack",
      "prerequisites": ["concept_stack", "concept_stack_operations"],
      "generic_hint": "Maintain a temporary stack in sorted order. Insert each popped value into the correct position by moving obstructing elements back to the original stack."
    },

    "concept_stack_sort_iterative_insertion": {
      "label": "Iterative Insertion Process",
      "parent_id": "concept_stack_sort",
      "prerequisites": ["concept_stack_sort", "concept_stack_operations"],
      "generic_hint": "Sorting emerges from repeatedly inserting each item into its correct position in the temp stack, not from a single pass."
    },

    "concept_stack_sort_comparison_condition": {
      "label": "Comparison Condition in Inner Loop",
      "parent_id": "concept_stack_sort",
      "prerequisites": ["concept_stack_sort", "concept_stack_operations"],
      "generic_hint": "The inner loop condition determines when items move between stacks. A wrong condition can cause unnecessary moves or incorrect ordering."
    },

    "concept_stack_sort_duplicates_handling": {
      "label": "Handling Duplicates in Stack Sort",
      "parent_id": "concept_stack_sort",
      "prerequisites": ["concept_stack_sort", "concept_stack_operations"],
      "generic_hint": "Use a consistent rule for equality (strict > vs >=) so duplicates are kept correctly and you don't infinite-loop or misplace equal items."
    },

    "concept_stack_edge_cases": {
      "label": "Edge Cases",
      "parent_id": "concept_stack",
      "prerequisites": [],
      "generic_hint": null
    },

    "concept_stack_edge_case_single_element": {
      "label": "Single Element",
      "parent_id": "concept_stack_edge_cases",
      "prerequisites": ["concept_stack_edge_cases"],
      "generic_hint": "A single element stack is already sorted. Ensure your algorithm doesn't pop from an empty stack or lose the element during transfers."
    },

    "concept_bt_traversal": {
      "label": "Tree Traversal",
      "parent_id": "concept_binary_tree",
      "prerequisites": ["concept_binary_tree"],
      "generic_hint": "Traversal defines the order in which nodes of a tree are visited."
    },

    "concept_bt_inorder_definition": {
      "label": "In-order Traversal (Left → Node → Right)",
      "parent_id": "concept_bt_traversal",
      "prerequisites": ["concept_bt_traversal"],
      "generic_hint": "In in-order traversal, recursively traverse the left subtree, then visit the node, then traverse the right subtree."
    },

    "concept_bt_recursive_subtree_processing": {
      "label": "Recursive Subtree Processing",
      "parent_id": "concept_bt_traversal",
      "prerequisites": ["concept_bt_traversal"],
      "generic_hint": "Each subtree is itself a binary tree. Apply the same traversal rule recursively to every subtree."
    },

    "concept_bt_traversal_rule_application": {
      "label": "Systematic Traversal Rule Application",
      "parent_id": "concept_bt_traversal",
      "prerequisites": ["concept_bt_traversal"],
      "generic_hint": "Do not rely on visual intuition. Apply the traversal rule consistently at every node."
    },

    "concept_bt_traversal_strategy": {
      "label": "Tracing Strategy for Traversal",
      "parent_id": "concept_bt_traversal",
      "prerequisites": ["concept_bt_traversal"],
      "generic_hint": "A reliable strategy for in-order is: go to the leftmost node, visit it, then move upward following Left → Node → Right."
    },

    "concept_bt_preorder_traversal": {
      "label": "Pre-order Traversal",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_tree_traversal"],
      "generic_hint": "Pre-order traversal visits nodes in the order: Root → Left Subtree → Right Subtree."
    },

    "concept_bt_preorder_definition": {
      "label": "Pre-order Traversal Definition",
      "parent_id": "concept_bt_preorder_traversal",
      "prerequisites": ["concept_bt_preorder_traversal"],
      "generic_hint": "For every node in the tree: first visit the node (Root), then recursively traverse its Left Subtree, followed by its Right Subtree."
    },

    "concept_bt_traversal_left_subtree_first": {
      "label": "Left Subtree before Right Subtree",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_tree_traversal"],
      "generic_hint": "In traversal types where Left precedes Right, the entire Left Subtree must be completed before moving to the Right Subtree."
    },

    "concept_bt_recursive_traversal": {
      "label": "Recursive Tree Traversal",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_tree_traversal"],
      "generic_hint": "Tree traversals are naturally defined using recursion: apply the traversal rule to the current node, then recursively apply it to the left and right subtrees."
    },
    "concept_bt_preorder_root_property": {
      "label": "Pre-order Traversal Root Property",
      "parent_id": "concept_bt_preorder_traversal",
      "prerequisites": ["concept_bt_preorder_traversal"],
      "generic_hint": "In Pre-order traversal, the first element in the sequence is always the root of the tree or subtree."
    },

    "concept_bt_inorder_subtree_partition": {
      "label": "In-order Subtree Partition Property",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_bt_inorder_definition"],
      "generic_hint": "In In-order traversal, once the root is located, all elements before it form the Left Subtree and all elements after it form the Right Subtree."
    },

    "concept_bt_tree_construction_from_traversals": {
      "label": "Constructing Binary Tree from Pre-order and In-order",
      "parent_id": "concept_tree_traversal",
      "prerequisites": [
        "concept_bt_preorder_root_property",
        "concept_bt_inorder_subtree_partition",
        "concept_bt_recursive_traversal"
      ],
      "generic_hint": "A binary tree can be constructed using Pre-order and In-order traversal sequences by identifying the root from Pre-order and partitioning the In-order sequence into left and right subtrees recursively."
    },
    "concept_bt_maxdepth": {
      "label": "Maximum Depth of Binary Tree",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_bt_traversal"],
      "generic_hint": "Maximum depth is the length of the longest path from the root to a leaf."
    },

    "concept_bt_maxdepth_base_case": {
      "label": "Base Case for maxDepth (None / Leaf)",
      "parent_id": "concept_bt_maxdepth",
      "prerequisites": ["concept_bt_maxdepth"],
      "generic_hint": "Define what maxDepth returns for an empty tree (None). With edge-counting depth, None is typically -1 so a leaf becomes 0."
    },

    "concept_bt_maxdepth_recursion": {
      "label": "Recursive Definition of maxDepth",
      "parent_id": "concept_bt_maxdepth",
      "prerequisites": ["concept_bt_maxdepth_base_case"],
      "generic_hint": "maxDepth(node) = max(maxDepth(node.left), maxDepth(node.right)) + 1."
    },

    "concept_bt_maxdepth_take_max": {
      "label": "Take Maximum of Subtree Depths",
      "parent_id": "concept_bt_maxdepth",
      "prerequisites": ["concept_bt_maxdepth_recursion"],
      "generic_hint": "Depth is determined by the deeper subtree, so choose the maximum, not the sum."
    },

    "concept_bt_maxdepth_traverse_both_sides": {
      "label": "Traverse Both Subtrees",
      "parent_id": "concept_bt_maxdepth",
      "prerequisites": ["concept_bt_maxdepth_recursion"],
      "generic_hint": "To find the longest path, compute depth for both left and right subtrees at every node."
    },
    "concept_binary_tree": {
      "label": "Binary Tree",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "A binary tree is a hierarchical data structure where each node has at most two children: left and right."
    },

    "concept_tree_traversal": {
      "label": "Tree Traversal",
      "parent_id": "concept_binary_tree",
      "prerequisites": ["concept_binary_tree"],
      "generic_hint": "Tree traversal is the process of visiting each node in the tree according to a specific order."
    },

    "concept_bt_level_order": {
      "label": "Level-order Traversal (Breadth-First Search)",
      "parent_id": "concept_tree_traversal",
      "prerequisites": ["concept_queue"],
      "generic_hint": "Level-order traversal (BFS) visits nodes level by level, from the root downward, using a queue."
    },

    "concept_queue_fifo": {
      "label": "FIFO Property (Queue Order)",
      "parent_id": "concept_queue",
      "prerequisites": ["concept_queue"],
      "generic_hint": "FIFO means the first element enqueued is the first element dequeued. This property is why BFS visits nodes level by level."
    },

    "concept_queue_empty_handling": {
      "label": "Empty Queue Handling",
      "parent_id": "concept_queue",
      "prerequisites": ["concept_queue"],
      "generic_hint": "Dequeue is only valid when the queue is not empty. If the queue is empty, there are no more nodes to process."
    },

    "concept_bt_bfs_dequeue_sets_cur": {
      "label": "Dequeue Sets Current Node (cur)",
      "parent_id": "concept_bt_level_order",
      "prerequisites": ["concept_queue_empty_handling"],
      "generic_hint": "In BFS, the next node to process is obtained by dequeuing from the queue. That dequeued node becomes the current node (cur)."
    },

    "concept_bt_bfs_process_node_fully": {
      "label": "Process Node Fully Before Next Dequeue",
      "parent_id": "concept_bt_level_order",
      "prerequisites": ["concept_bt_bfs_dequeue_sets_cur"],
      "generic_hint": "For each dequeued node: (1) visit/print it, then (2) enqueue its children. Only then move on to the next dequeue."
    },

    "concept_bt_bfs_process_children": {
      "label": "Enqueue Children During BFS",
      "parent_id": "concept_bt_level_order",
      "prerequisites": ["concept_bt_bfs_process_node_fully"],
      "generic_hint": "After visiting a node in BFS, enqueue its children so they will be visited in the correct level-order later."
    },

    "concept_bt_bfs_enqueue_left_then_right": {
      "label": "Enqueue Left Child Then Right Child",
      "parent_id": "concept_bt_level_order",
      "prerequisites": ["concept_bt_bfs_process_children"],
      "generic_hint": "To preserve standard left-to-right order within a level, enqueue the left child first, then the right child."
    },

    "concept_bt_bfs_null_check_children": {
      "label": "Null Check Before Enqueue",
      "parent_id": "concept_bt_level_order",
      "prerequisites": ["concept_bt_bfs_enqueue_left_then_right"],
      "generic_hint": "Only enqueue existing (non-null) child nodes. Null children should be skipped to avoid invalid dequeues."
    },
    "concept_binary_search_tree": {
      "label": "Binary Search Tree (BST)",
      "parent_id": "concept_binary_tree",
      "prerequisites": ["concept_binary_tree"],
      "generic_hint": "A Binary Search Tree is a binary tree in which, for every node, all keys in the left subtree are smaller than the node’s key and all keys in the right subtree are larger."
    },

    "concept_bst_ordering_property": {
      "label": "BST Ordering Property",
      "parent_id": "concept_binary_search_tree",
      "prerequisites": ["concept_binary_search_tree"],
      "generic_hint": "For every node in a BST: left subtree keys < node key < right subtree keys."
    },

    "concept_ll_linear_search": {
      "label": "Linear Search on Linked List",
      "parent_id": "concept_linked_list",
      "prerequisites": [
        "concept_linked_list",
        "concept_ll_traversal",
        "concept_algorithm_analysis"
      ],
      "generic_hint": "Linear search scans nodes one by one until the target is found or the end of the list is reached."
    },

    "concept_ll_linear_search_count_comparisons": {
      "label": "Counting Comparisons in Linear Search",
      "parent_id": "concept_ll_linear_search",
      "prerequisites": ["concept_ll_linear_search"],
      "generic_hint": "In linear search, one (Q.item == X) comparison is performed for each node visited during the scan."
    },

    "concept_ll_position_of_match_affects_cost": {
      "label": "Position of Match Affects Cost",
      "parent_id": "concept_ll_linear_search",
      "prerequisites": ["concept_ll_linear_search_count_comparisons"],
      "generic_hint": "The number of comparisons depends on the position of the matching element. If the match appears later in the list, more comparisons are performed."
    },

    "concept_ll_nested_traversal_outer_vs_inner": {
      "label": "Nested Traversal (Outer Loop vs Inner Scan)",
      "parent_id": "concept_ll_linear_search",
      "prerequisites": ["concept_ll_linear_search"],
      "generic_hint": "When a function calls another search function inside a loop, the total cost includes both the outer loop and the inner scan."
    },
    "concept_ll_case_analysis": {
      "label": "Best Case vs Worst Case Analysis",
      "parent_id": "concept_ll_linear_search",
      "prerequisites": ["concept_ll_linear_search"],
      "generic_hint": "Case analysis considers inputs that make an algorithm run fastest (best case) or slowest (worst case)."
    },

    "concept_ll_best_vs_worst_case_early_termination": {
      "label": "Early Termination (Best vs Worst Case)",
      "parent_id": "concept_ll_case_analysis",
      "prerequisites": ["concept_ll_case_analysis"],
      "generic_hint": "If an algorithm can stop early, the best case often occurs when it terminates quickly. Worst case often requires delayed termination after much work is done."
    },

    "concept_ll_worst_case_full_scan_on_failure": {
      "label": "Worst Case: Full Scan on Failure",
      "parent_id": "concept_ll_case_analysis",
      "prerequisites": ["concept_ll_case_analysis"],
      "generic_hint": "For linear search, the worst case occurs when the target is absent or appears only at the end, forcing a full scan through the list."
    },

    "concept_ll_worst_case_conditions_success_vs_failure": {
      "label": "Worst-case Conditions (Success vs Failure Searches)",
      "parent_id": "concept_ll_case_analysis",
      "prerequisites": ["concept_ll_case_analysis"],
      "generic_hint": "Worst-case inputs often combine many long successful searches with an additional failed search that requires scanning the entire list."
    },

    "concept_worst_case_analysis": {
      "label": "Worst-Case Analysis",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "Worst-case analysis considers the input that causes the maximum number of operations."
    },

    "concept_linear_search_inner_cost": {
      "label": "Cost of Linear Search",
      "parent_id": "concept_worst_case_analysis",
      "prerequisites": ["concept_worst_case_analysis"],
      "generic_hint": "A linear search may require scanning all elements in the list, giving Θ(n) time in the worst case."
    },

    "concept_nested_traversal_worst_case": {
      "label": "Nested Traversals",
      "parent_id": "concept_worst_case_analysis",
      "prerequisites": ["concept_worst_case_analysis"],
      "generic_hint": "When one loop is inside another, the total running time in the worst case is often multiplicative."
    },

    "concept_multiplicative_growth_nested_loops": {
      "label": "Multiplicative Growth in Nested Loops",
      "parent_id": "concept_nested_traversal_worst_case",
      "prerequisites": ["concept_nested_traversal_worst_case"],
      "generic_hint": "If an O(n) operation is performed inside a loop that runs O(m) times, the total worst-case time is O(mn)."
    },
    "concept_algorithm_analysis": {
      "label": "Algorithm Analysis",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "Algorithm analysis studies how running time grows as a function of input size."
    },

    "concept_nested_loop_tracing": {
      "label": "Tracing Nested Loops",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "To analyse nested loops, trace each loop carefully and count how many times the inner statement executes."
    },

    "concept_nested_loop_iteration_count": {
      "label": "Counting Iterations in Nested Loops",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_nested_loop_tracing"],
      "generic_hint": "When loops are nested, compute the number of iterations of each loop separately before combining them."
    },

    "concept_logarithmic_growth_doubling": {
      "label": "Logarithmic Growth (Doubling Pattern)",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "If a variable doubles each iteration (k = 1, 2, 4, 8, ...), the loop runs in O(log N) time."
    },
    "concept_logarithmic_loop": {
      "label": "Logarithmic-Time Loop",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "If a loop variable grows multiplicatively (e.g., doubles each iteration), the loop runs in logarithmic time."
    },

    "concept_logarithmic_loop_off_by_one": {
      "label": "Off-by-One in Logarithmic Loops",
      "parent_id": "concept_logarithmic_loop",
      "prerequisites": ["concept_logarithmic_loop"],
      "generic_hint": "When counting iterations in a doubling loop starting at 1, the number of iterations is floor(log₂(N)) + 1."
    },

    "concept_logarithm_base_interpretation": {
      "label": "Logarithm Base Interpretation",
      "parent_id": "concept_logarithmic_loop",
      "prerequisites": ["concept_logarithmic_loop"],
      "generic_hint": "When a variable doubles each iteration, the loop count corresponds to log base 2."
    },

    "concept_geometric_progression_loop_count": {
      "label": "Geometric Progression in Loop Analysis",
      "parent_id": "concept_logarithmic_loop",
      "prerequisites": ["concept_logarithmic_loop"],
      "generic_hint": "A sequence like 1, 2, 4, 8, ... forms a geometric progression. Counting how many terms are ≤ N determines the number of loop iterations."
    },
    "concept_logarithmic_loop_growth": {
      "label": "Logarithmic Growth in Loops",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_logarithmic_loop"],
      "generic_hint": "If a loop variable changes multiplicatively (e.g., doubles or triples each iteration), the loop runs in logarithmic time."
    },

    "concept_nested_loops_multiplicative_cost": {
      "label": "Nested Loops – Multiplicative Cost",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_nested_loop_iteration_count"],
      "generic_hint": "When one loop is inside another, their iteration counts multiply in the worst case."
    },

    "concept_logarithm_rules_and_change_of_base": {
      "label": "Logarithm Rules and Change of Base",
      "parent_id": "concept_logarithmic_loop",
      "prerequisites": ["concept_logarithmic_loop"],
      "generic_hint": "Different logarithm bases differ only by constant factors in Big-O notation. Products of logarithms can behave like (log N)²."
    },
    "concept_recursion": {
      "label": "Recursion",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "A recursive function solves a problem by calling itself on smaller inputs until reaching a base case."
    },

    "concept_recursion_tree": {
      "label": "Recursion Tree Method",
      "parent_id": "concept_recursion",
      "prerequisites": ["concept_recursion"],
      "generic_hint": "A recursion tree helps you visualise recursive calls level by level and sum the work done at each level."
    },

    "concept_recursion_tree_expansion": {
      "label": "Expanding Recursive Calls",
      "parent_id": "concept_recursion_tree",
      "prerequisites": ["concept_recursion_tree"],
      "generic_hint": "When a function calls itself multiple times, each call repeats its own local work and spawns further recursive calls."
    },

    "concept_recursion_level_summing": {
      "label": "Summing Work Per Level",
      "parent_id": "concept_recursion_tree",
      "prerequisites": ["concept_recursion_tree"],
      "generic_hint": "Count how many calls occur at each recursion depth, multiply by the work per call at that level, and sum across levels."
    },

    "concept_recurrence_relation": {
      "label": "Recurrence Relation",
      "parent_id": "concept_recursion",
      "prerequisites": ["concept_recursion"],
      "generic_hint": "A recurrence relation describes the running time (or operation count) in terms of smaller input sizes."
    },

    "concept_recurrence_linear_plus_recursive": {
      "label": "Linear Work + Recursive Work",
      "parent_id": "concept_recurrence_relation",
      "prerequisites": ["concept_recurrence_relation"],
      "generic_hint": "Many recurrences have the form T(N) = a·T(N−1) + f(N). You must account for both branching (the a·T term) and the extra work done in each call (the f(N) term)."
    },
    "concept_recurrence_counting_recursive_calls": {
      "label": "Counting Recursive Calls in a Recurrence",
      "parent_id": "concept_recurrence_relation",
      "prerequisites": ["concept_recurrence_relation"],
      "generic_hint": "When forming a recurrence, count exactly how many recursive calls are made and what input size each call uses."
    },

    "concept_match_code_to_recurrence": {
      "label": "Matching Code Structure to a Recurrence",
      "parent_id": "concept_recurrence_relation",
      "prerequisites": ["concept_recurrence_relation"],
      "generic_hint": "Build the recurrence directly from the code: identify the number of recursive calls, their argument sizes, and the extra work done in the current call."
    },
    "concept_recursion_tree_exponential_growth": {
      "label": "Exponential Growth in Recursion Trees",
      "parent_id": "concept_recursion_tree",
      "prerequisites": ["concept_recursion_tree_expansion"],
      "generic_hint": "If each recursive call generates a constant number greater than 1 of smaller calls, the total number of calls can grow exponentially."
    },

    "concept_dominant_term_in_recurrence": {
      "label": "Dominant Term in a Recurrence",
      "parent_id": "concept_recurrence_relation",
      "prerequisites": ["concept_recurrence_relation"],
      "generic_hint": "When analysing a recurrence, identify which term grows fastest. That term determines the overall time complexity."
    },

    "concept_compare_growth_rates": {
      "label": "Comparing Growth Rates",
      "parent_id": "concept_algorithm_analysis",
      "prerequisites": ["concept_algorithm_analysis"],
      "generic_hint": "Exponential growth (e.g., 2^N) is faster than polynomial growth (e.g., N²), but slower than factorial growth (N!)."
    },

    "concept_binary_search": {
      "label": "Binary Search",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "Repeatedly divide a sorted sequence in half to locate a target or property."
    },

    "concept_binary_search_boundary_decision": {
      "label": "Binary Search Boundary Decision",
      "parent_id": "concept_binary_search",
      "prerequisites": ["concept_binary_search"],
      "generic_hint": "The choice of comparison boundary determines which half of the array is explored."
    },

    "concept_binary_search_boundary_conditions": {
      "label": "Binary Search Boundary Conditions",
      "parent_id": "concept_binary_search",
      "prerequisites": ["concept_binary_search_boundary_decision"],
      "generic_hint": "Correctly updating low and high pointers prevents infinite loops and off-by-one errors."
    },

    "concept_binary_search_sorted_segment_check": {
      "label": "Sorted Segment Detection",
      "parent_id": "concept_binary_search",
      "prerequisites": ["concept_binary_search"],
      "generic_hint": "If a segment is strictly increasing, its first element is the minimum."
    },

    "concept_binary_search_base_case": {
      "label": "Binary Search Base Case",
      "parent_id": "concept_binary_search",
      "prerequisites": ["concept_binary_search"],
      "generic_hint": "When the search interval reduces to one element, that element is the answer."
    },
    "concept_hash_table": {
      "label": "Hash Table",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "A hash table is a data structure that maps keys to values using a hash function."
    },
    "concept_ht_load_factor": {
      "label": "Load Factor (α)",
      "parent_id": "concept_hash_table",
      "prerequisites": ["concept_hash_table"],
      "generic_hint": "Load factor measures how full a hash table is. It is commonly defined as α = n / m."
    },

    "concept_ht_load_factor_compute_n": {
      "label": "Computing Required n from α",
      "parent_id": "concept_ht_load_factor",
      "prerequisites": ["concept_ht_load_factor"],
      "generic_hint": "Given α and m, the required number of stored items is n = α × m."
    },

    "concept_ht_load_factor_over_under": {
      "label": "Overfilled vs Underfilled (relative to α)",
      "parent_id": "concept_ht_load_factor",
      "prerequisites": ["concept_ht_load_factor_compute_n"],
      "generic_hint": "If the row has n greater than α×m it is overfilled; if n is less than α×m it is underfilled."
    },
    "concept_ht_linear_probing_worst_case": {
      "label": "Worst Case (Linear Probing)",
      "parent_id": "concept_ht_linear_probing",
      "prerequisites": ["concept_ht_linear_probing"],
      "generic_hint": "Worst case occurs when primary clustering forms, causing long probe sequences before insertion."
    },
    "concept_radix_representation": {
      "label": "Radix (Base) Representation",
      "parent_id": "concept_hash_function_design",
      "prerequisites": ["concept_hash_function_design"],
      "generic_hint": "A number can be interpreted in base b using positional notation: a·b^k + ... + d."
    },
    "concept_modulo_operation": {
      "label": "Modulo Operation",
      "parent_id": "concept_hash_function_design",
      "prerequisites": ["concept_hash_function_design"],
      "generic_hint": "The modulo operation returns the remainder after division and is commonly used to map hash values into table indices."
    },
    "concept_trie": {
      "label": "Trie (Prefix Tree)",
      "parent_id": null,
      "prerequisites": [],
      "generic_hint": "A trie is a tree-based data structure for efficient string operations; it is also called a prefix tree."
    },
    "concept_trie_word_search": {
      "label": "Search a Word in a Trie",
      "parent_id": "concept_trie",
      "prerequisites": ["concept_trie"],
      "generic_hint": "Search proceeds character-by-character by following child links. If a required child does not exist, the word is not in the trie."
    },
    "concept_trie_end_of_word": {
      "label": "End-of-Word Marker (is_end_of_word)",
      "parent_id": "concept_trie",
      "prerequisites": ["concept_trie_word_search"],
      "generic_hint": "A string is a valid stored word only if its final node is marked as end-of-word (is_end_of_word = True)."
    },
    "concept_trie_children_iteration": {
      "label": "Trie Children Traversal (first_child / next_sibling)",
      "parent_id": "concept_trie",
      "prerequisites": ["concept_trie"],
      "generic_hint": "If children are stored as a linked list (first_child, next_sibling), you must iterate siblings to visit every child."
    },

    "concept_trie_alphabetical_traversal": {
      "label": "Alphabetical Output from a Trie",
      "parent_id": "concept_trie",
      "prerequisites": ["concept_trie_children_iteration"],
      "generic_hint": "To list words in alphabetical order, visit children in sorted character order before recursing."
    }
  },
  "runtime_rules": [
    {
      "id": "attr_none_deref",
      "match": { "exception": "AttributeError", "contains": ["NoneType"] },
      "fail_node_id": "node_runtime_attr_none"
    },
    {
      "id": "index_oob",
      "match": {
        "exception": "IndexError",
        "contains": ["list index out of range"]
      },
      "fail_node_id": "node_runtime_index_oob"
    },
    {
      "id": "syntax_error",
      "match": { "exception": "SyntaxError" },
      "fail_node_id": "node_runtime_syntax"
    },
    {
      "id": "indent_error",
      "match": { "exception": "IndentationError" },
      "fail_node_id": "node_runtime_indentation"
    },
    {
      "id": "recursion_depth",
      "match": { "exception": "RecursionError" },
      "fail_node_id": "node_runtime_recursion"
    },
    {
      "id": "type_error",
      "match": { "exception": "TypeError" },
      "fail_node_id": "node_runtime_type"
    },
    {
      "id": "value_error",
      "match": { "exception": "ValueError" },
      "fail_node_id": "node_runtime_value"
    }
  ],
  "graph_nodes": {
    "l1_c1_p1_node_evens_basic": {
      "hint_text": "Your odds and evens are not ending up in the right halves. First keep all odd numbers in their original order, then all even numbers in their original order.",
      "concept_id": "concept_ll_stable_partition",
      "penalties": {
        "concept_ll_stable_partition": -0.2,
        "concept_ll_traversal": -0.05,
        "concept_ll_pointer_updates": -0.05
      }
    },
    "l1_c1_p1_node_evens_all_even": {
      "hint_text": "When every value is even, moving them to the back should not change the list at all.",
      "concept_id": "concept_ll_all_even",
      "penalties": {
        "concept_ll_all_even": -0.2,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c1_p1_node_evens_all_odd": {
      "hint_text": "If there are no even numbers, the list should remain exactly the same after your function.",
      "concept_id": "concept_ll_all_odd",
      "penalties": {
        "concept_ll_all_odd": -0.2,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c1_p1_node_evens_stability": {
      "hint_text": "Be careful not to shuffle the order of odds among themselves or evens among themselves when you move nodes around.",
      "concept_id": "concept_ll_stable_partition",
      "penalties": {
        "concept_ll_stable_partition": -0.2,
        "concept_ll_traversal": -0.05,
        "concept_ll_tail_pointer_handling": -0.05
      }
    },
    "l1_c1_p1_node_evens_head_update": {
      "hint_text": "If the first element is even, are you correctly updating the head pointer? Make sure odd numbers become the new front of the list.",
      "concept_id": "concept_ll_head_pointer_update",
      "penalties": {
        "concept_ll_head_pointer_update": -0.2,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c1_p1_node_evens_tail_handling": {
      "hint_text": "If the last element is even, ensure it remains properly linked at the end. Be careful not to lose the tail when rearranging nodes.",
      "concept_id": "concept_ll_tail_pointer_handling",
      "penalties": {
        "concept_ll_tail_pointer_handling": -0.2,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c1_p1_node_evens_single_element": {
      "hint_text": "Have you considered the case where the list contains only one node? Make sure you handle this edge case correctly.",
      "concept_id": "concept_ll_single_node_handling",
      "penalties": {
        "concept_ll_single_node_handling": -0.2,
        "concept_ll_edge_case_no_change": -0.05
      }
    },
    "l1_c1_p2_node_max_not_front": {
      "hint_text": "After your function runs, the largest value in the list should become the head node. Verify you are relinking nodes so the max node is first, not just swapping values incorrectly.",
      "concept_id": "concept_ll_head_pointer_update",
      "penalties": {
        "concept_ll_head_pointer_update": -0.2,
        "concept_ll_pointer_updates": -0.05,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c2_p1_node_duplicates_basic": {
      "hint_text": "Because the list is sorted, duplicates appear next to each other. Traverse the list and whenever current.data == current.next.data, delete the next node by relinking current.next to current.next.next. Keep skipping until the next value is different.",
      "concept_id": "concept_ll_sorted_consecutive_duplicates",
      "penalties": {
        "concept_ll_sorted_consecutive_duplicates": -0.2,
        "concept_ll_traversal": -0.05,
        "concept_ll_pointer_updates": -0.05
      }
    },
    "l1_c2_p1_node_no_duplicates": {
      "hint_text": "If there are no duplicates, your function should leave the list unchanged. Make sure you don't delete nodes when current.data != current.next.data.",
      "concept_id": "concept_ll_edge_case_no_change",
      "penalties": {
        "concept_ll_edge_case_no_change": -0.2,
        "concept_ll_traversal": -0.05
      }
    },
    "l1_c2_p1_node_duplicates_all_same": {
      "hint_text": "When all values are the same, the final list should contain exactly one node. You should keep the first node and remove every following node by repeatedly relinking next pointers.",
      "concept_id": "concept_ll_collapse_to_single_node",
      "penalties": {
        "concept_ll_collapse_to_single_node": -0.2,
        "concept_ll_traversal": -0.05,
        "concept_ll_pointer_updates": -0.05
      }
    },
    "l1_c2_p1_node_duplicates_multiple_blocks": {
      "hint_text": "There can be many duplicate blocks (e.g., 1s then 2s then 3s). Ensure your traversal continues through the entire list and collapses every block, not just the first one.",
      "concept_id": "concept_ll_traversal",
      "penalties": {
        "concept_ll_traversal": -0.2
      }
    },
    "l1_c3_p1_node_circ_last_next_assignment": {
      "hint_text": "To form a circular linked list, the last node’s next pointer must be assigned to head. Using '==' only compares values and does not modify the link.",
      "concept_id": "concept_ll_circular_link_assignment",
      "penalties": {
        "concept_ll_circular_link_assignment": -0.2
      }
    },
    "l1_c3_p1_node_erroneous_return_statement": {
      "hint_text": "Check what your function returns. A linked list function should usually return the head node. Returning None or a wrong variable will break the list logic.",
      "concept_id": "concept_function_return_value",
      "penalties": {
        "concept_function_return_value": -0.2
      }
    },
    "l1_c3_p1_node_func_call_missing_arguments": {
      "hint_text": "Ensure that every function call provides the correct number of arguments according to the function definition. Missing parameters will cause runtime errors.",
      "concept_id": "concept_function_parameters_arguments",
      "penalties": {
        "concept_function_parameters_arguments": -0.2
      }
    },
    "l1_c3_p1_node_wrong_variable_bptr": {
      "hint_text": "Compare how a_ptr and b_ptr are computed. Make sure you are using the correct index variable when locating b_ptr.",
      "concept_id": "concept_variable_usage_logic",
      "penalties": {
        "concept_variable_usage_logic": -0.2
      }
    },
    "l1_c3_p1_node_main_guard_usage": {
      "hint_text": "Consider how the code runs and the entry point. Is there any missing colon somewhere?",
      "concept_id": "concept_program_execution_environment",
      "penalties": {
        "concept_program_execution_environment": -0.2
      }
    },
    "l1_c4_p1_node_circle_adjacent": {
      "hint_text": "Aptr and Bptr are too close together. In a circular list of 10 nodes, splitting equally requires selecting nodes that are 5 steps apart, not neighbours.",
      "concept_id": "concept_ll_circular_distance",
      "penalties": {
        "concept_ll_circular_distance": -0.2
      }
    },
    "l1_c4_p1_node_circle_wrong_distance": {
      "hint_text": "Count how many nodes you traverse from Aptr until you reach Bptr. For an equal split in a 10-node circular list, the distance must be exactly n/2 = 5 nodes.",
      "concept_id": "concept_ll_circular_half_split",
      "penalties": {
        "concept_ll_circular_half_split": -0.2
      }
    },
    "l1_c4_p1_node_circle_swapped": {
      "hint_text": "The distance between the nodes looks correct, but remember that T2Q1(s, q) modifies the link before q. The order of parameters affects which sub-circle is formed.",
      "concept_id": "concept_function_parameter_order",
      "penalties": {
        "concept_function_parameter_order": -0.2
      }
    },
    "l1_c4_p1_node_circle_opposite_wrong_pair": {
      "hint_text": "Not every opposite pair works. Recall that the function finds the node before q and redirects its next pointer to s. The cut must occur at the correct boundary of the circle.",
      "concept_id": "concept_ll_pointer_reassignment_circular",
      "penalties": {
        "concept_ll_pointer_reassignment_circular": -0.2
      }
    },
    "l2_c1_p1_general_hint": {
      "hint_text": "Don’t read the expression left-to-right directly. Use operator precedence to decide what is evaluated first, and remember postfix outputs an operator only after its operands are ready.",
      "concept_id": "concept_infix_to_postfix_general",
      "penalties": {
        "concept_infix_to_postfix_general": -0.2
      }
    },
    "l2_c1_p1_add_vs_multiplication_precedence": {
      "hint_text": "*, /, and % have higher precedence than + and -. Convert the subexpression 'b * c % d' first before combining it with 'a + ...'.",
      "concept_id": "concept_operator_precedence_table",
      "penalties": {
        "concept_operator_precedence_table": -0.2
      }
    },
    "l2_c1_p1_assignment_wrong_position": {
      "hint_text": "The assignment operator '=' has the lowest precedence. First convert the entire right-hand side into postfix form, then place '=' only after the full RHS is formed.",
      "concept_id": "concept_assignment_lowest_precedence",
      "penalties": {
        "concept_assignment_lowest_precedence": -0.2
      }
    },
    "l2_c1_p2_general_hint": {
      "hint_text": "Break the prefix into chunks by the outermost operators: '=' is the outermost, then '&&' combines two big parts. Convert the left part (a << b) and the right part (c >> (d + e)) first, then join with &&, and finally attach to y with '='.",
      "concept_id": "concept_prefix_to_infix_general",
      "penalties": {
        "concept_prefix_to_infix_general": -0.2
      }
    },
    "l2_c1_p2_add_vs_shift_precedence": {
      "hint_text": "Remember that + has higher precedence than << and >>. Form (d + e) first, then use it as the right operand of the shift: c >> (d + e).",
      "concept_id": "concept_operator_precedence_table",
      "penalties": {
        "concept_operator_precedence_table": -0.2
      }
    },
    "l2_c1_p2_shift_vs_and_precedence": {
      "hint_text": "Shifts (<<, >>) have higher precedence than logical &&. Treat (a << b) and (c >> (d + e)) as two complete subexpressions before applying && between them.",
      "concept_id": "concept_operator_precedence_table",
      "penalties": {
        "concept_operator_precedence_table": -0.2
      }
    },
    "l2_c1_p2_assignment_wrong_position": {
      "hint_text": "In this prefix expression, '=' is the outermost operator. That means y is assigned the value of the entire expression after it. Build the full RHS first, then place '=' with y on the left.",
      "concept_id": "concept_assignment_lowest_precedence",
      "penalties": {
        "concept_assignment_lowest_precedence": -0.2
      }
    },
    "l2_c1_p3_general_hint": {
      "hint_text": "Use the standard postfix→prefix stack procedure: scan left-to-right, push operands; when you see an operator, pop the right operand then the left operand, build a new prefix fragment (op left right), and push it back. The final stack item is the full prefix expression.",
      "concept_id": "concept_postfix_to_prefix_general",
      "penalties": {
        "concept_postfix_to_prefix_general": -0.2
      }
    },
    "l2_c1_p3_stack_not_used": {
      "hint_text": "If you just reverse or read postfix directly, operators will attach to the wrong operands. For postfix to prefix, use a stack to simulate the process: push operands; on an operator, pop two expressions (right first, then left), combine into '(op left right)', and push back.",
      "concept_id": "concept_stack_usage_in_postfix_to_prefix",
      "penalties": {
        "concept_stack_usage_in_postfix_to_prefix": -0.2
      }
    },
    "l2_c2_p1_general_hint": {
      "hint_text": "Think in two phases: move everything out of the stack into the queue, then move everything back from the queue into the stack. Use only pop/push for the stack and enqueue/dequeue for the queue.",
      "concept_id": "concept_reverse_stack_with_queue_general",
      "penalties": {
        "concept_reverse_stack_with_queue_general": -0.2
      }
    },
    "l2_c2_p1_never_used_queue": {
      "hint_text": "A stack alone cannot reverse itself under these operation constraints. You must transfer items into the queue (enqueue) and then move them back into the stack (push) to reverse the order.",
      "concept_id": "concept_reverse_stack_with_queue_general",
      "penalties": {
        "concept_reverse_stack_with_queue_general": -0.2
      }
    },
    "l2_c2_p1_rotated_before_transfer": {
      "hint_text": "Don’t rotate or rearrange the queue midway. First move all stack items into the queue. Only after the transfer is complete should you start moving items back to the stack.",
      "concept_id": "concept_queue_order_preservation",
      "penalties": {
        "concept_queue_order_preservation": -0.2
      }
    },
    "l2_c2_p1_messed_partial_order": {
      "hint_text": "To reverse the entire stack, you must remove every item from the stack and enqueue it, then dequeue every item and push it back. If you leave some items behind or stop early, the final order will not be fully reversed.",
      "concept_id": "concept_full_transfer_required",
      "penalties": {
        "concept_full_transfer_required": -0.2
      }
    },
    "l2_c2_p2_general_hint": {
      "hint_text": "Treat the queue as two segments: the first k items (which you will manipulate) and the remaining n-k items (which must stay in the same relative order). Use a stack only on the first k items, then rotate the queue to restore the front segment position.",
      "concept_id": "concept_reverse_first_k_of_queue_with_stack_general",
      "penalties": {
        "concept_reverse_first_k_of_queue_with_stack_general": -0.2
      }
    },
    "l2_c2_p2_never_used_stack": {
      "hint_text": "A queue alone cannot reverse the first k items under the allowed operations. Dequeue the first k items into a stack (push), then pop them back into the queue to reverse their order.",
      "concept_id": "concept_stack_usage_for_first_k",
      "penalties": {
        "concept_stack_usage_for_first_k": -0.2
      }
    },
    "l2_c2_p2_touched_tail_segment": {
      "hint_text": "Only the first k items should be moved into the stack. If you dequeue more than k, you will disturb the remaining n-k items that must stay in their original order.",
      "concept_id": "concept_queue_segment_preservation",
      "penalties": {
        "concept_queue_segment_preservation": -0.2
      }
    },
    "l2_c2_p2_rotated_too_early": {
      "hint_text": "Queue rotation (moving front items to the back) should happen only after you have reversed the first k items and enqueued them back. Rotating too early scrambles which items belong to the first-k segment.",
      "concept_id": "concept_queue_rotation_timing",
      "penalties": {
        "concept_queue_rotation_timing": -0.2
      }
    },
    "l2_c2_p3_node_sortstack_basic": {
      "hint_text": "Use exactly one temporary stack. Repeatedly pop from the original stack, and insert that value into the temp stack in sorted position by moving larger items back to the original stack first. Then push the value into temp and move the displaced items back.",
      "concept_id": "concept_stack_sort",
      "penalties": {
        "concept_stack_sort": -0.2
      }
    },
    "l2_c2_p3_node_sortstack_already_sorted": {
      "hint_text": "If the stack is already ascending, your algorithm should effectively do minimal movement. Double-check your comparison inside the inner loop so you don't move items back and forth unnecessarily.",
      "concept_id": "concept_stack_sort_comparison_condition",
      "penalties": {
        "concept_stack_sort_comparison_condition": -0.2,
        "concept_stack_sort": -0.05
      }
    },
    "l2_c2_p3_node_sortstack_reverse_sorted": {
      "hint_text": "A reverse-sorted stack is the worst case: you must repeatedly move multiple items between the two stacks to maintain sorted order in the temp stack after each insertion.",
      "concept_id": "concept_stack_sort_iterative_insertion",
      "penalties": {
        "concept_stack_sort_iterative_insertion": -0.2,
        "concept_stack_operations": -0.05,
        "concept_stack_sort": -0.05
      }
    },
    "l2_c2_p3_node_sortstack_duplicates": {
      "hint_text": "Handle equal values carefully. Decide whether to move items only when tempTop > current (strict) or tempTop >= current (non-strict). This choice affects where duplicates end up.",
      "concept_id": "concept_stack_sort_duplicates_handling",
      "penalties": {
        "concept_stack_sort_duplicates_handling": -0.2,
        "concept_stack_sort_comparison_condition": -0.05
      }
    },
    "l2_c2_p3_node_sortstack_single": {
      "hint_text": "With one element, there is no need to sort. If this fails, your push/pop logic may be incorrect when the stack becomes empty or when transferring back at the end.",
      "concept_id": "concept_stack_edge_case_single_element",
      "penalties": {
        "concept_stack_edge_case_single_element": -0.2,
        "concept_stack_operations": -0.05
      }
    },
    "l3_c1_p1_bt_inorder_root_first": {
      "hint_text": "In in-order traversal, you should not visit the root first. Always fully traverse the left subtree before visiting the node itself.",
      "concept_id": "concept_bt_inorder_definition",
      "penalties": {
        "concept_bt_inorder_definition": -0.2
      }
    },

    "l3_c1_p1_bt_inorder_left_not_finished": {
      "hint_text": "You clicked a node before completing everything in its left subtree. In-order traversal is recursive: fully finish the left subtree before visiting the parent node.",
      "concept_id": "concept_bt_recursive_subtree_processing",
      "penalties": {
        "concept_bt_recursive_subtree_processing": -0.2
      }
    },

    "l3_c1_p1_bt_inorder_visual_guessing": {
      "hint_text": "Traversal order is determined by structure, not by visual appearance. For every node, apply Left → Node → Right systematically.",
      "concept_id": "concept_bt_traversal_rule_application",
      "penalties": {
        "concept_bt_traversal_rule_application": -0.2
      }
    },

    "l3_c1_p1_bt_inorder_general_hint": {
      "hint_text": "Start from the leftmost node in the tree. Then move upward, applying Left → Node → Right at every subtree. Think recursively instead of guessing.",
      "concept_id": "concept_bt_traversal_strategy",
      "penalties": {
        "concept_bt_traversal_strategy": -0.2
      }
    },
    "l3_c1_p2_bt_preorder_not_root_first": {
      "hint_text": "Pre-order traversal visits the Root first. According to the traversal definition, the order is Root → Left Subtree → Right Subtree. The root must be selected before any child nodes.",
      "concept_id": "concept_bt_preorder_traversal",
      "penalties": {
        "concept_bt_preorder_traversal": -0.2
      }
    },

    "l3_c1_p2_bt_preorder_right_before_left": {
      "hint_text": "In Pre-order traversal, after visiting the Root, you must completely traverse the Left Subtree before moving to the Right Subtree.",
      "concept_id": "concept_bt_traversal_left_subtree_first",
      "penalties": {
        "concept_bt_traversal_left_subtree_first": -0.2
      }
    },

    "l3_c1_p2_bt_preorder_visual_guessing": {
      "hint_text": "Traversal depends on the tree structure, not the visual layout. Apply the Pre-order rule (Root → Left → Right) recursively at every subtree.",
      "concept_id": "concept_bt_recursive_traversal",
      "penalties": {
        "concept_bt_recursive_traversal": -0.2
      }
    },

    "l3_c1_p2_bt_preorder_general_hint": {
      "hint_text": "Apply the traversal rule systematically: visit the Root node, then recursively traverse the Left Subtree, and finally recursively traverse the Right Subtree.",
      "concept_id": "concept_bt_preorder_definition",
      "penalties": {
        "concept_bt_preorder_definition": -0.2
      }
    },
    "l3_c1_p3_wrong_node_for_root": {
      "hint_text": "In Pre-order traversal, the first element is always the Root of the tree. Recheck the first element of the Pre-order sequence.",
      "concept_id": "concept_bt_preorder_root_property",
      "penalties": {
        "concept_bt_preorder_root_property": -0.2
      }
    },

    "l3_c1_p3_wrong_side_of_binary_tree": {
      "hint_text": "After identifying the Root, locate it in the In-order sequence. All elements to the left of the Root belong to the Left Subtree, and all elements to the right belong to the Right Subtree.",
      "concept_id": "concept_bt_inorder_subtree_partition",
      "penalties": {
        "concept_bt_inorder_subtree_partition": -0.2
      }
    },

    "l3_c1_p3_general_hint": {
      "hint_text": "Step 1: Take the first element of the Pre-order sequence as the Root. Step 2: Split the In-order sequence into Left and Right Subtrees. Step 3: Recursively repeat this process for each subtree.",
      "concept_id": "concept_bt_tree_construction_from_traversals",
      "penalties": {
        "concept_bt_tree_construction_from_traversals": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_single_node": {
      "hint_text": "A single-node tree has maximum depth 0 (counting edges). Make sure your base case handles an empty child correctly and your recursion returns 0 for a leaf.",
      "concept_id": "concept_bt_maxdepth_base_case",
      "penalties": {
        "concept_bt_maxdepth_base_case": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_basic_height": {
      "hint_text": "Maximum depth is computed recursively: max(depth(left), depth(right)) + 1. Check whether you add 1 after taking the maximum of the two subtree depths.",
      "concept_id": "concept_bt_maxdepth_recursion",
      "penalties": {
        "concept_bt_maxdepth_recursion": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_skewed_left": {
      "hint_text": "For a left-skewed tree, the maximum depth is entirely in the left subtree. Ensure your recursion explores the left child correctly until it reaches None.",
      "concept_id": "concept_bt_maxdepth_traverse_both_sides",
      "penalties": {
        "concept_bt_maxdepth_traverse_both_sides": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_skewed_right": {
      "hint_text": "For a right-skewed tree, the maximum depth is entirely in the right subtree. Ensure your recursion explores the right child correctly until it reaches None.",
      "concept_id": "concept_bt_maxdepth_traverse_both_sides",
      "penalties": {
        "concept_bt_maxdepth_traverse_both_sides": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_unbalanced_tree": {
      "hint_text": "In an unbalanced tree, one subtree can be deeper. You must take the maximum of the left and right subtree depths (not sum them).",
      "concept_id": "concept_bt_maxdepth_take_max",
      "penalties": {
        "concept_bt_maxdepth_take_max": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_null_children_handling": {
      "hint_text": "If a child is None, its depth should be treated as -1 (if you count edges) so that a leaf ends up as 0 after +1. Check your base case for None carefully.",
      "concept_id": "concept_bt_maxdepth_base_case",
      "penalties": {
        "concept_bt_maxdepth_base_case": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_complete_tree": {
      "hint_text": "In a multi-level tree, the recursion must continue until it reaches the deepest leaf. Make sure you compute both subtrees at every node and take the maximum.",
      "concept_id": "concept_bt_maxdepth_traverse_both_sides",
      "penalties": {
        "concept_bt_maxdepth_traverse_both_sides": -0.2
      }
    },

    "l3_c2_p1_node_maxdepth_zigzag_structure": {
      "hint_text": "The longest root-to-leaf path may alternate left and right. Your function must evaluate both subtrees at each node and keep the maximum depth found.",
      "concept_id": "concept_bt_maxdepth_traverse_both_sides",
      "penalties": {
        "concept_bt_maxdepth_traverse_both_sides": -0.2
      }
    },

    "l3_c2_p2_print_before_dequeue_cur_is_null": {
      "hint_text": "cur is still null. In level-order traversal, you must Dequeue a node into cur before you can Print cur.item.",
      "concept_id": "concept_bt_bfs_dequeue_sets_cur",
      "penalties": {
        "concept_bt_bfs_dequeue_sets_cur": -0.2
      }
    },

    "l3_c2_p2_enqueue_right_before_left_wrong_order": {
      "hint_text": "Within the same level, the standard level-order traversal enqueues the left child before the right child. Enqueue cur.left first, then cur.right.",
      "concept_id": "concept_bt_bfs_enqueue_left_then_right",
      "penalties": {
        "concept_bt_bfs_enqueue_left_then_right": -0.2
      }
    },

    "l3_c2_p2_forget_enqueue_one_child": {
      "hint_text": "If cur has two children, both should be enqueued (as long as they exist). Missing one child causes missing nodes in later output.",
      "concept_id": "concept_bt_bfs_process_children",
      "penalties": {
        "concept_bt_bfs_process_children": -0.2
      }
    },

    "l3_c2_p2_enqueue_null_child_or_no_null_check": {
      "hint_text": "Only enqueue children that exist. If you enqueue null, you'll get invalid steps later when you dequeue.",
      "concept_id": "concept_bt_bfs_null_check_children",
      "penalties": {
        "concept_bt_bfs_null_check_children": -0.2
      }
    },

    "l3_c2_p2_treat_queue_like_stack_lifo": {
      "hint_text": "A queue is FIFO (First-In-First-Out), not LIFO. The first node enqueued must be the first node dequeued—don’t treat it like a stack.",
      "concept_id": "concept_queue_fifo",
      "penalties": {
        "concept_queue_fifo": -0.2
      }
    },

    "l3_c2_p2_dequeue_too_many_times_skips_nodes": {
      "hint_text": "After you Dequeue into cur, you should complete the node’s processing (Print cur.item, then enqueue its children) before dequeuing again.",
      "concept_id": "concept_bt_bfs_process_node_fully",
      "penalties": {
        "concept_bt_bfs_process_node_fully": -0.2
      }
    },

    "l3_c2_p2_dequeue_when_queue_is_empty": {
      "hint_text": "The queue is empty—there is nothing to dequeue. You need to enqueue nodes first (or you already finished processing all reachable nodes).",
      "concept_id": "concept_queue_empty_handling",
      "penalties": {
        "concept_queue_empty_handling": -0.2
      }
    },

    "l3_c2_p3_choosing_a_smaller_value_than_target_value": {
      "hint_text": "In a Binary Search Tree (BST), all keys in the left subtree are smaller than the node’s key. If the target value is smaller than the current node’s value, you should move to the left child.",
      "concept_id": "concept_bst_ordering_property",
      "penalties": {
        "concept_bst_ordering_property": -0.2
      }
    },

    "l3_c2_p3_choosing_a_larger_value_than_target_value": {
      "hint_text": "In a Binary Search Tree (BST), all keys in the right subtree are larger than the node’s key. If the target value is larger than the current node’s value, you should move to the right child.",
      "concept_id": "concept_bst_ordering_property",
      "penalties": {
        "concept_bst_ordering_property": -0.2
      }
    },
    "l4_c1_p1_q1_node_counts_only_successful_searches": {
      "hint_text": "You are undercounting. Even when an element is found, element(X, Q) still performs comparisons against each earlier node visited. Count every (Q.item == X) comparison until the match is found (or Q becomes None).",
      "concept_id": "concept_ll_linear_search_count_comparisons",
      "penalties": {
        "concept_ll_linear_search_count_comparisons": -0.2
      }
    },

    "l4_c1_p1_q1_node_stops_after_first_found_instead_of_scan": {
      "hint_text": "You assumed each element() call needs only 1 comparison when the value exists. However, element() may scan several nodes before reaching the match. Check the position of 4 in Relics—it is not at the beginning.",
      "concept_id": "concept_ll_position_of_match_affects_cost",
      "penalties": {
        "concept_ll_position_of_match_affects_cost": -0.2
      }
    },

    "l4_c1_p1_q1_node_counts_only_elements_in_L": {
      "hint_text": "You counted only the outer loop over L. The real work happens inside element(X, Relics), which scans Relics and performs one (Q.item == X) comparison per node visited.",
      "concept_id": "concept_ll_nested_traversal_outer_vs_inner",
      "penalties": {
        "concept_ll_nested_traversal_outer_vs_inner": -0.2
      }
    },
    "l4_c1_p1_q2_node_wrong_thinks_missing_early_is_worst": {
      "hint_text": "If the first element of L is not in R, subset() stops immediately after one element() call. That is usually fast, not worst-case. Worst-case happens when you spend a long time searching before you can stop.",
      "concept_id": "concept_ll_best_vs_worst_case_early_termination",
      "penalties": {
        "concept_ll_best_vs_worst_case_early_termination": -0.2
      }
    },

    "l4_c1_p1_q2_node_wrong_ignores_final_failed_search_cost": {
      "hint_text": "Having the first |L|-1 elements found near the end of R is already costly, but worst-case is even worse when the final search fails only after scanning all of R (the last element of L is not in R).",
      "concept_id": "concept_ll_worst_case_full_scan_on_failure",
      "penalties": {
        "concept_ll_worst_case_full_scan_on_failure": -0.2
      }
    },

    "l4_c1_p1_q2_node_wrong_thinks_all_present_at_end_is_worst": {
      "hint_text": "If all elements of L are present (even near the end of R), each element() call eventually succeeds. The typical worst-case for subset-check occurs when many searches are long and the final one fails only after a full scan of R.",
      "concept_id": "concept_ll_worst_case_conditions_success_vs_failure",
      "penalties": {
        "concept_ll_worst_case_conditions_success_vs_failure": -0.2
      }
    },
    "l4_c1_p1_q3_node_focuses_only_on_R": {
      "hint_text": "If you chose Θ(|R|), you may be focusing only on the inner search. But subset() loops over every element in O, and for each one it may scan through R. So the total cost depends on both |O| and |R|.",
      "concept_id": "concept_nested_traversal_worst_case",
      "penalties": {
        "concept_nested_traversal_worst_case": -0.2
      }
    },

    "l4_c1_p1_q3_node_focuses_only_on_O": {
      "hint_text": "If you chose Θ(|O|), you may be assuming that element() runs in constant time. However, element() performs a linear scan of R, which can take up to |R| comparisons in the worst case.",
      "concept_id": "concept_linear_search_inner_cost",
      "penalties": {
        "concept_linear_search_inner_cost": -0.2
      }
    },

    "l4_c1_p1_q3_node_adds_instead_of_multiplies": {
      "hint_text": "Θ(|O| + |R|) usually applies when each list is traversed once. Here, for each element in O, you may traverse R again. That repeated scanning leads to multiplicative growth in the worst case.",
      "concept_id": "concept_multiplicative_growth_nested_loops",
      "penalties": {
        "concept_multiplicative_growth_nested_loops": -0.2
      }
    },
    "l4_c1_p2_q1_node_counts_outer_or_off_by_one": {
      "hint_text": "Make sure you are counting the calls to Seal() inside the inner loop. The outer loop controls how many rounds happen, but Seal() is called each time k doubles (1, 2, 4, 8, ... while k ≤ N). Trace the exact sequence for N = 8.",
      "concept_id": "concept_nested_loop_tracing",
      "penalties": {
        "concept_nested_loop_tracing": -0.2
      }
    },

    "l4_c1_p2_q1_node_multiplies_incorrectly": {
      "hint_text": "First determine how many times the outer loop runs when j multiplies by 3 (j = 1, 3, 9, ...). Then count how many times the inner loop runs when k doubles (k = 1, 2, 4, 8, ...). Combine them carefully—don’t assume both loops run N times.",
      "concept_id": "concept_nested_loop_iteration_count",
      "penalties": {
        "concept_nested_loop_iteration_count": -0.2
      }
    },

    "l4_c1_p2_q1_node_treats_doubling_as_linear": {
      "hint_text": "Notice that k does not increase by 1—it doubles each time. That means the inner loop runs in logarithmic steps, not N steps. Write out the exact k values for N = 8 to see how many times Seal() is actually called.",
      "concept_id": "concept_logarithmic_growth_doubling",
      "penalties": {
        "concept_logarithmic_growth_doubling": -0.2
      }
    },
    "l4_c1_p2_q2_node_missing_plus_one": {
      "hint_text": "The loop starts with k = 1 and continues while k ≤ N. Since k doubles each time (1, 2, 4, 8, ...), you must count the starting value k = 1 as one iteration. That’s why the answer is not just log₂(N), but floor(log₂(N)) + 1.",
      "concept_id": "concept_logarithmic_loop_off_by_one",
      "penalties": {
        "concept_logarithmic_loop_off_by_one": -0.2
      }
    },

    "l4_c1_p2_q2_node_log_base_confusion": {
      "hint_text": "Because k doubles each time (k *= 2), the growth is base 2. The number of times you can double 1 before exceeding N is related to log₂(N), not a logarithm with an unspecified base.",
      "concept_id": "concept_logarithm_base_interpretation",
      "penalties": {
        "concept_logarithm_base_interpretation": -0.2
      }
    },

    "l4_c1_p2_q2_node_forgets_starting_value": {
      "hint_text": "Try listing the values of k for a small N (e.g., N = 8): 1, 2, 4, 8. There are 4 iterations. Since log₂(8) = 3, you need one extra count for the starting value.",
      "concept_id": "concept_geometric_progression_loop_count",
      "penalties": {
        "concept_geometric_progression_loop_count": -0.2
      }
    },
    "l4_c1_p2_q3_node_base_confusion_log2": {
      "hint_text": "Notice that j multiplies by 3 each time (j *= 3), not by 2. So the growth follows powers of 3: 1, 3, 9, 27, ... The number of iterations is therefore related to log₃(N), not log₂(N).",
      "concept_id": "concept_logarithm_matches_growth_factor",
      "penalties": {
        "concept_logarithm_matches_growth_factor": -0.2
      }
    },

    "l4_c1_p2_q3_node_unspecified_log_base": {
      "hint_text": "Since j grows as powers of 3, the correct logarithm must have base 3. Writing just log(N) without specifying the base hides this important detail.",
      "concept_id": "concept_logarithm_base_interpretation",
      "penalties": {
        "concept_logarithm_base_interpretation": -0.2
      }
    },

    "l4_c1_p2_q3_node_missing_plus_one": {
      "hint_text": "Try listing the actual values of j for a small N (e.g., N = 9): 1, 3, 9. That gives 3 iterations. Since log₃(9) = 2, you need to add 1 to account for the starting value j = 1. That’s why the answer is floor(log₃(N)) + 1.",
      "concept_id": "concept_geometric_progression_off_by_one",
      "penalties": {
        "concept_geometric_progression_off_by_one": -0.2
      }
    },
    "l4_c1_p2_q4_node_assumes_linear_growth": {
      "hint_text": "Neither loop increases by +1. The inner loop doubles k (k *= 2) and the outer loop triples j (j *= 3), so both loops run in logarithmic time. Since neither loop is linear, the overall complexity cannot be O(N).",
      "concept_id": "concept_logarithmic_loop_growth",
      "penalties": {
        "concept_logarithmic_loop_growth": -0.2
      }
    },

    "l4_c1_p2_q4_node_collapses_nested_logs": {
      "hint_text": "Because the loops are nested, their iteration counts multiply: log₂(N) × log₃(N). You should not simplify this to just O(log N), since both logarithmic factors contribute multiplicatively.",
      "concept_id": "concept_nested_loops_multiplicative_cost",
      "penalties": {
        "concept_nested_loops_multiplicative_cost": -0.2
      }
    },

    "l4_c1_p2_q4_node_confuses_log_squared_identity": {
      "hint_text": "Be careful with logarithm rules. log(N²) equals 2·log(N), which is still O(log N). Here, however, you have (log₂(N))·(log₃(N)), which behaves like (log N)² up to constant factors (by change of base).",
      "concept_id": "concept_logarithm_rules_and_change_of_base",
      "penalties": {
        "concept_logarithm_rules_and_change_of_base": -0.2
      }
    },
    "l4_c1_p3_q1_node_counts_only_first_call": {
      "hint_text": "It looks like you counted only the first call’s loop (Read() done N times). But Book(N) also makes two recursive calls to Book(N−1), and each of those calls performs its own Read() loop as well.",
      "concept_id": "concept_recursion_tree_expansion",
      "penalties": {
        "concept_recursion_tree_expansion": -0.2
      }
    },

    "l4_c1_p3_q1_node_overcounts_recursive_levels": {
      "hint_text": "Try expanding level by level without double-counting. From N = 3: you have 1 call at N = 3, then 2 calls at N = 2, then 4 calls at N = 1. Each call contributes exactly N Read() operations at its level. Sum the reads across these levels.",
      "concept_id": "concept_recursion_level_summing",
      "penalties": {
        "concept_recursion_level_summing": -0.2
      }
    },

    "l4_c1_p3_q1_node_ignores_work_per_call": {
      "hint_text": "Don’t count only the branching. Each call to Book(N) also performs a loop that executes Read() N times. So the total includes both the recursive structure (two calls each time) and the per-call linear work.",
      "concept_id": "concept_recurrence_linear_plus_recursive",
      "penalties": {
        "concept_recurrence_linear_plus_recursive": -0.2
      }
    },

    "l4_c1_p3_q2_node_misses_second_recursive_call": {
      "hint_text": "Book(N) makes two recursive calls to Book(N−1), not one. So the recurrence must include 2·W(N−1). Also remember that each call performs N Read() operations in its loop.",
      "concept_id": "concept_recurrence_counting_recursive_calls",
      "penalties": {
        "concept_recurrence_counting_recursive_calls": -0.2
      }
    },

    "l4_c1_p3_q2_node_not_fibonacci_structure": {
      "hint_text": "This recursion is not Fibonacci-style. Both recursive calls are Book(N−1); there is no Book(N−2) term. Match the recurrence directly to the calls made in the code.",
      "concept_id": "concept_match_code_to_recurrence",
      "penalties": {
        "concept_match_code_to_recurrence": -0.2
      }
    },

    "l4_c1_p3_q2_node_missing_linear_term": {
      "hint_text": "Each call to Book(N) performs N Read() operations before the recursive calls. So besides 2·W(N−1), you must add the linear term +N.",
      "concept_id": "concept_recurrence_linear_plus_recursive",
      "penalties": {
        "concept_recurrence_linear_plus_recursive": -0.2
      }
    },
    "l4_c1_p3_q3_node_quadratic_misinterpretation": {
      "hint_text": "At each level, Book(N) makes two recursive calls to Book(N−1). This branching leads to exponential growth in the number of calls. A quadratic complexity O(N²) grows much more slowly than an exponential recursion tree.",
      "concept_id": "concept_recursion_tree_exponential_growth",
      "penalties": {
        "concept_recursion_tree_exponential_growth": -0.2
      }
    },

    "l4_c1_p3_q3_node_linear_misinterpretation": {
      "hint_text": "Although each call performs N Read() operations, the dominant factor is the two recursive calls to Book(N−1). This creates a binary recursion tree, which grows exponentially rather than linearly.",
      "concept_id": "concept_dominant_term_in_recurrence",
      "penalties": {
        "concept_dominant_term_in_recurrence": -0.2
      }
    },

    "l4_c1_p3_q3_node_factorial_misinterpretation": {
      "hint_text": "Factorial time typically occurs when each level branches into N, N−1, N−2, ... calls. Here, each level makes exactly two recursive calls. That leads to exponential growth like 2^N, not N!.",
      "concept_id": "concept_compare_growth_rates",
      "penalties": {
        "concept_compare_growth_rates": -0.2
      }
    },
    "l4_c1_p4_node_already_sorted_segment": {
      "hint_text": "If the current segment is already strictly increasing, then the first element is the minimum. You can detect this before continuing binary search.",
      "concept_id": "concept_binary_search_sorted_segment_check"
    },

    "l4_c1_p4_node_compare_wrong_boundary": {
      "hint_text": "To decide which half contains the minimum, compare arr[mid] with the right boundary. Comparing with the left boundary may not always give the correct direction.",
      "concept_id": "concept_binary_search_boundary_decision"
    },

    "l4_c1_p4_node_rotation_binary_search": {
      "hint_text": "Apply a divide-and-conquer approach. If arr[mid] is greater than arr[high], the minimum lies in the right half; otherwise, it lies in the left half.",
      "concept_id": "concept_divide_and_conquer_binary_search"
    },

    "l4_c1_p4_node_single_element": {
      "hint_text": "If the search interval reduces to a single element, that element must be the minimum.",
      "concept_id": "concept_binary_search_base_case"
    },

    "l4_c1_p4_node_two_element_boundary": {
      "hint_text": "When only two elements remain (e.g., [2,1]), ensure your boundary update logic still identifies the smaller value correctly.",
      "concept_id": "concept_binary_search_boundary_conditions"
    },

    "l5_c1_p1_general_hint": {
      "hint_text": "Convert each row’s target into an exact required book count: n = α × m. Multiply the target load factor by the number of shelves in that row.",
      "concept_id": "concept_ht_load_factor_compute_n",
      "penalties": {
        "concept_ht_load_factor_compute_n": -0.2
      }
    },

    "l5_c1_p1_bookreturn_row_overfilled": {
      "hint_text": "This row has too many books for its target. Move books out until the row’s count n matches the required value (n = α × m).",
      "concept_id": "concept_ht_load_factor_over_under",
      "penalties": {
        "concept_ht_load_factor_over_under": -0.2
      }
    },

    "l5_c1_p2_row_underfilled": {
      "hint_text": "You still have empty slots. Fill every slot in the table before evaluating.",
      "concept_id": "concept_ht_open_addressing_table_state",
      "penalties": {
        "concept_ht_open_addressing_table_state": -0.2
      }
    },

    "l5_c1_p2_best_general_hint": {
      "hint_text": "Best case for linear probing: every key is placed into its first hashed slot, so there are no collisions and no probing steps.",
      "concept_id": "concept_ht_linear_probing_best_case",
      "penalties": {
        "concept_ht_linear_probing_best_case": -0.2
      }
    },
    "l5_c1_p2_worst_general_hint": {
      "hint_text": "Worst case for linear probing occurs when many keys hash to the same initial slot, forming one long contiguous cluster. New insertions must probe through almost the entire cluster before finding an empty slot.",
      "concept_id": "concept_ht_linear_probing_worst_case",
      "penalties": {
        "concept_ht_linear_probing_worst_case": -0.2
      }
    },

    "l5_c3_p1_node_hint_01_general_hint": {
      "hint_text": "Treat 1779 as a number in base 8 using positional notation: a·8^3 + b·8^2 + c·8 + d.",
      "concept_id": "concept_radix_representation",
      "penalties": {
        "concept_radix_representation": -0.2
      }
    },

    "l5_c3_p1_node_hint_02_place_values": {
      "hint_text": "Compute 8^3 = 512, 8^2 = 64, 8^1 = 8. Divide step-by-step to extract each digit from highest place value to lowest.",
      "concept_id": "concept_radix_representation",
      "penalties": {
        "concept_radix_representation": -0.2
      }
    },

    "l5_c3_p1_node_hint_03_mapping_check": {
      "hint_text": "After finding the digits, convert them into the corresponding letters as instructed.",
      "concept_id": null
    },

    "l5_c3_p2_node_hint_01_letter_conversion": {
      "hint_text": "Replace the letters with numbers using A=1, B=2, C=3. Write down the numeric version of each string first.",
      "concept_id": null
    },

    "l5_c3_p2_node_hint_02_build_base8_number": {
      "hint_text": "Use positional notation in base 8: first letter × 8^2, second letter × 8^1, last letter × 8^0. Then add them together.",
      "concept_id": "concept_radix_representation",
      "penalties": {
        "concept_radix_representation": -0.2
      }
    },

    "l5_c3_p2_node_hint_03_apply_modulus": {
      "hint_text": "After computing the number, divide it by 7 and take the remainder. The remainder is the hash value.",
      "concept_id": "concept_modulo_operation",
      "penalties": {
        "concept_modulo_operation": -0.2
      }
    },

    "l5_c3_p2_node_hint_04_notice_permutation": {
      "hint_text": "All three strings contain the same letters in different order. Think about whether their final values might end up the same.",
      "concept_id": "concept_hash_collisions",
      "penalties": {
        "concept_hash_collisions": -0.2
      }
    },

    "l6_c1_p1_trie_prefix_only_not_word": {
      "hint_text": "A path in a trie is not automatically a valid word. The word only counts if the path ends exactly at a terminal (end-of-word) node. If you stop too early, it’s only a prefix.",
      "concept_id": "concept_trie_end_of_word",
      "penalties": {
        "concept_trie_end_of_word": -0.2
      }
    },
    "l6_c1_p1_trie_wrong_branch_choice": {
      "hint_text": "After choosing the first letter, you must follow the correct child branch for the next character. If the next character is not available as a child node, that word cannot be formed.",
      "concept_id": "concept_trie_word_search",
      "penalties": {
        "concept_trie_word_search": -0.2
      }
    },
    "l6_c1_p1_trie_missing_character_step": {
      "hint_text": "You skipped a character. In a trie, each step down the tree represents exactly one next letter in the word—no letters can be jumped over.",
      "concept_id": "concept_trie_word_search",
      "penalties": {
        "concept_trie_word_search": -0.2
      }
    },
    "l6_c1_p1_trie_extra_character_step": {
      "hint_text": "You added an extra letter beyond what the trie supports. Even if a shorter word exists, a longer word is only valid if the trie continues with matching child nodes and ends at a terminal node.",
      "concept_id": "concept_trie_end_of_word",
      "penalties": {
        "concept_trie_end_of_word": -0.2
      }
    },
    "l6_c1_p1_trie_confuse_similar_words": {
      "hint_text": "Be careful with similar-looking options (e.g., 'rat' vs 'rap' vs 'rapt'). Trace the trie letter by letter, and confirm the terminal node at the exact final letter.",
      "concept_id": "concept_trie_word_search",
      "penalties": {
        "concept_trie_word_search": -0.2
      }
    },
    "l6_c1_p1_trie_visual_guessing": {
      "hint_text": "Don’t choose words based on what 'looks' likely. Start at the root, follow each letter down, and only accept the word if you land on a terminal node at the end.",
      "concept_id": "concept_trie_word_search",
      "penalties": {
        "concept_trie_word_search": -0.2
      }
    },
    "l6_c3_p1_node_trie_prefix_core": {
      "hint_text": "First walk down the trie from trie.root following the prefix characters one by one. Only after reaching the node for the last prefix character should you start collecting words below it.",
      "concept_id": "concept_trie_word_search",
      "penalties": {
        "concept_trie_word_search": -0.2
      }
    },

    "l6_c3_p1_node_trie_prefix_alphabetical": {
      "hint_text": "Children are stored using first_child + next_sibling. To output words in alphabetical order, gather all children of a node, sort them by child.char, then DFS in that sorted order.",
      "concept_id": "concept_trie_alphabetical_traversal",
      "penalties": {
        "concept_trie_alphabetical_traversal": -0.2
      }
    },

    "l6_c3_p1_node_trie_prefix_not_found": {
      "hint_text": "If any prefix character is missing during the walk-down, there are no matches. Return [\"empty!\"] (a list with one string) so the program prints empty! and does not crash.",
      "concept_id": "concept_output_contract_empty_marker",
      "penalties": {
        "concept_output_contract_empty_marker": -0.2
      }
    },

    "l6_c3_p1_node_trie_prefix_word_vs_prefix": {
      "hint_text": "After reaching the prefix node, if node.is_end_of_word is True, include the prefix itself as a result before exploring deeper children (e.g., prefix=\"app\" matches \"app\").",
      "concept_id": "concept_trie_end_of_word",
      "penalties": {
        "concept_trie_end_of_word": -0.2
      }
    },

    "l6_c3_p1_node_trie_prefix_sibling_traversal": {
      "hint_text": "When exploring children, don’t stop at first_child. Walk through every next_sibling and explore each branch so you don’t miss valid words.",
      "concept_id": "concept_trie_children_iteration",
      "penalties": {
        "concept_trie_children_iteration": -0.2
      }
    },
    "node_runtime_attr_none": {
      "hint_text": "You tried to access an attribute on None (null). In linked lists, this often means you used cur.next.item when cur.next was None at the tail. Add a guard like: while cur and cur.next.",
      "concept_id": "concept_runtime_null_checks",
      "penalties": {
        "concept_runtime_null_checks": -0.2
      }
    },
    "node_runtime_index_oob": {
      "hint_text": "You accessed an index that doesn't exist (index out of range). Check loops over arrays/lists and make sure indices stay within 0..len-1.",
      "concept_id": "concept_runtime_bounds_checking",
      "penalties": {
        "concept_runtime_bounds_checking": -0.2
      }
    },
    "node_runtime_syntax": {
      "hint_text": "Your code has a syntax error (Python couldn't parse it). Check missing colons, mismatched brackets/quotes, and invalid indentation blocks.",
      "concept_id": "concept_runtime_syntax_errors",
      "penalties": {
        "concept_runtime_syntax_errors": -0.2
      }
    },
    "node_runtime_indentation": {
      "hint_text": "Your code has an indentation error. In Python, blocks must be consistently indented (spaces recommended). Make sure the function body and if/while blocks align correctly.",
      "concept_id": "concept_runtime_indentation_errors",
      "penalties": {
        "concept_runtime_indentation_errors": -0.2
      }
    },
    "node_runtime_recursion": {
      "hint_text": "Your recursion never stops (max recursion depth exceeded). Check your base case and make sure each recursive call moves toward it.",
      "concept_id": "concept_runtime_recursion_base_case",
      "penalties": {
        "concept_runtime_recursion_base_case": -0.2
      }
    },
    "node_runtime_type": {
      "hint_text": "A TypeError happened: an operation was applied to the wrong type (e.g., adding int to str, calling a non-function, etc.). Print/debug variable types near the failing line.",
      "concept_id": "concept_runtime_type_errors",
      "penalties": {
        "concept_runtime_type_errors": -0.2
      }
    },
    "node_runtime_value": {
      "hint_text": "A ValueError happened: a conversion or operation got an invalid value (e.g., int('abc')). Check parsing and assumptions about input format.",
      "concept_id": "concept_runtime_value_errors",
      "penalties": {
        "concept_runtime_value_errors": -0.2
      }
    },
    "node_runtime_generic": {
      "hint_text": "Your program crashed before producing an answer. Read the error message (stderr) and check the line where it failed to see what was None / out of range / wrong type.",
      "concept_id": "concept_runtime_error_debugging",
      "penalties": {
        "concept_runtime_error_debugging": -0.2
      }
    }
  }
}
