{
  "problems": {
    "l1_c1_p1": {
      "description": "Move all even integers to the back of the linked list, preserving relative order of odds and evens.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "evens_tc_01",
          "input": "1,2,3,4,5",
          "expected_output": "1,3,5,2,4",
          "fail_node_id": "node_evens_core"
        },
        {
          "id": "evens_tc_02",
          "input": "2,4,6",
          "expected_output": "2,4,6",
          "fail_node_id": "node_evens_all_even"
        },
        {
          "id": "evens_tc_03",
          "input": "1,3,5",
          "expected_output": "1,3,5",
          "fail_node_id": "node_evens_all_odd"
        },
        {
          "id": "evens_tc_04",
          "input": "2,1,4,3,6,5",
          "expected_output": "1,3,5,2,4,6",
          "fail_node_id": "node_evens_stability"
        }
      ]
    },
    "l1_c1_p2": {
      "description": "Move the node with the maximum value to the front of the linked list.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "max_tc_01",
          "input": "1,2,3,4,5",
          "expected_output": "5,1,2,3,4",
          "fail_node_id": "node_max_not_front"
        },
        {
          "id": "max_tc_02",
          "input": "5,4,3,2,1",
          "expected_output": "5,4,3,2,1",
          "fail_node_id": "node_max_already_front"
        },
        {
          "id": "max_tc_03",
          "input": "2,2,2,2",
          "expected_output": "2,2,2,2",
          "fail_node_id": "node_max_all_equal"
        },
        {
          "id": "max_tc_04",
          "input": "1,5,3,5,4",
          "expected_output": "5,1,3,5,4",
          "fail_node_id": "node_max_multiple"
        }
      ]
    },
    "l1_c2_p1": {
      "description": "Remove duplicates from a sorted linked list so that each value appears only once.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "dup_tc_01",
          "input": "1,1,2,3,3,3",
          "expected_output": "1,2,3",
          "fail_node_id": "node_dups_core"
        },
        {
          "id": "dup_tc_02",
          "input": "1,2,3,4",
          "expected_output": "1,2,3,4",
          "fail_node_id": "node_dups_nochange"
        },
        {
          "id": "dup_tc_03",
          "input": "2,2,2,2",
          "expected_output": "2",
          "fail_node_id": "node_dups_all_same"
        },
        {
          "id": "dup_tc_04",
          "input": "1,1,1,2,2,3,3,3,3",
          "expected_output": "1,2,3",
          "fail_node_id": "node_dups_multiple_blocks"
        }
      ]
    },
    "l1_c3_p1": {
      "description": "Identify the 5 bugs (2 syntax, 3 logical) in the linked-list door unlocking code.",
      "type": "scroll_bug_finder",
      "bug_targets": [
        {
          "id": "bug_last_node_assignment",
          "concept_node_id": "node_circ_last_next_assignment"
        },
        {
          "id": "bug_erroneous_return_statement",
          "concept_node_id": "node_erroneous_return_statement"
        },
        {
          "id": "bug_half_unlock_missing_arg",
          "concept_node_id": "node_func_call_missing_arguments"
        },
        {
          "id": "bug_bptr_uses_a_index",
          "concept_node_id": "node_wrong_variable_bptr"
        },
        {
          "id": "bug_main_guard_usage",
          "concept_node_id": "node_main_guard_usage"
        }
      ]
    },
    "l1_c4_p1": {
      "description": "Choose Aptr and Bptr on a 10-node circular list so that full_unlock splits the circle into two equal rings.",
      "type": "circle_two_pointers",
      "checker": "circle_two_pointers",
      "params": {
        "n_nodes": 10,
        "correct_aptr_idx": 2,
        "correct_bptr_idx": 7,
        "must_match_order": false
      },
      "error_mapping": {
        "ERR_SAME": "node_circle_same",
        "ERR_ADJACENT": "node_circle_adjacent",
        "ERR_WRONG_DISTANCE": "node_circle_wrong_distance",
        "ERR_WRONG_ORDER": "node_circle_swapped"
      }
    },
    "l2_c1_p1": {
      "type": "puzzle",
      "expression": "x = a + b * c % d >> e",
      "tests_concepts": [
        "infix_to_postfix",
        "operator_precedence",
        "stack_usage"
      ],
      "error_patterns": [
        "ignore_precedence_add_vs_mult",
        "ignore_precedence_shift_vs_add",
        "assignment_operator_wrong_place",
        "no_stack_just_read_left_to_right"
      ]
    },
    "l2_c1_p2": {
      "description": "Convert the prefix expression '= y && << a b >> c + d e' into a correct infix expression.",
      "type": "puzzle",
      "concepts": [
        "prefix_to_infix",
        "operator_precedence",
        "stack_usage",
        "expression_grouping"
      ],
      "error_patterns": [
        "l2_c1_p2_ignore_precedence_add_vs_shift",
        "l2_c1_p2_ignore_precedence_shift_vs_and",
        "l2_c1_p2_assignment_wrong_position",
        "l2_c1_p2_stack_not_used",
        "l2_c1_p2_missing_and_operator",
        "l2_c1_p2_random_walk"
      ]
    },
    "l2_c1_p3": {
      "description": "Convert the postfix expression 'x a b c * d % + e >> =' into a correct prefix expression.",
      "type": "puzzle",
      "concepts": [
        "postfix_to_prefix",
        "operator_precedence",
        "stack_usage",
        "expression_grouping",
        "assignment_operator"
      ],
      "error_patterns": [
        "l2_c1_p3_stack_not_used",
        "l2_c1_p3_assignment_wrong_position",
        "l2_c1_p3_wrong_grouping_add_vs_shift",
        "l2_c1_p3_random_walk"
      ]
    },
    "l2_c2_p1": {
      "description": "Reverse all items in the stack using only queue operations. You may only push and pop from the top of the stack, and enqueue/dequeue from the ends of the queue.",
      "type": "puzzle",
      "concepts": [
        "stack_reversal",
        "queue_usage",
        "stack",
        "queue",
        "algorithmic_thinking"
      ],
      "error_patterns": [
        "l2_c2_p1_never_used_queue",
        "l2_c2_p1_rotated_before_transfer",
        "l2_c2_p1_messed_partial_order",
        "l2_c2_p1_wrong_operation_order",
        "l2_c2_p1_random_walk"
      ]
    },
    "l2_c2_p2": {
      "description": "Reorder the first k items of the queue using the stack so that those k items are restored to the correct order, while the remaining items stay in their original positions.",
      "type": "puzzle",
      "concepts": [
        "queue_k_reversal",
        "queue",
        "stack",
        "algorithmic_thinking"
      ],
      "error_patterns": [
        "l2_c2_p2_missing_stack",
        "l2_c2_p2_touched_tail_segment",
        "l2_c2_p2_rotated_too_early",
        "l2_c2_p2_wrong_operation_order",
        "l2_c2_p2_random_walk"
      ]
    },
    "l2_c2_p3": {
      "description": "Sort a stack in ascending order using only push/pop operations and one temporary stack.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "sortstack_tc_01_basic",
          "input": "3,1,4,2",
          "expected_output": "1,2,3,4",
          "fail_node_id": "node_sortstack_core"
        },
        {
          "id": "sortstack_tc_02_already_sorted",
          "input": "1,2,3,4",
          "expected_output": "1,2,3,4",
          "fail_node_id": "node_sortstack_already_sorted"
        },
        {
          "id": "sortstack_tc_03_reverse_sorted",
          "input": "4,3,2,1",
          "expected_output": "1,2,3,4",
          "fail_node_id": "node_sortstack_reverse_sorted"
        },
        {
          "id": "sortstack_tc_04_with_duplicates",
          "input": "3,1,2,1,3",
          "expected_output": "1,1,2,3,3",
          "fail_node_id": "node_sortstack_duplicates"
        },
        {
          "id": "sortstack_tc_05_single",
          "input": "7",
          "expected_output": "7",
          "fail_node_id": "node_sortstack_single"
        }
      ]
    },
    "l3_c1_p1": {
      "description": "Click the binary tree nodes in the correct In-order traversal sequence. A wrong click resets the puzzle.",
      "type": "puzzle",
      "concepts": [
        "binary_tree",
        "tree_traversal",
        "inorder_traversal",
        "recursion"
      ],
      "error_patterns": [
        "l3_c1_p1_bt_inorder_root_first",
        "l3_c1_p1_bt_inorder_left_not_finished",
        "l3_c1_p1_bt_inorder_skipped_right_subtree",
        "l3_c1_p1_bt_inorder_visual_guessing",
        "l3_c1_p1_bt_inorder_bst_sorted_assumption",
        "l3_c1_p1_bt_inorder_random_walk"
      ]
    },
    "l3_c1_p2": {
      "description": "Click the binary tree nodes in the correct Pre-order traversal sequence. A wrong click resets the puzzle.",
      "type": "puzzle",
      "concepts": [
        "binary_tree",
        "tree_traversal",
        "preorder_traversal",
        "recursion"
      ],
      "error_patterns": [
        "l3_c1_p2_bt_preorder_not_root_first",
        "l3_c1_p2_bt_preorder_left_skipped",
        "l3_c1_p2_bt_preorder_right_before_left",
        "l3_c1_p2_bt_preorder_visual_guessing",
        "l3_c1_p2_bt_preorder_subtree_not_finished",
        "l3_c1_p2_bt_preorder_random_walk"
      ]
    },
    "l3_c1_p3": {
      "description": "Place the nodes in the tree using information from the previous 2 puzzles.",
      "type": "puzzle",
      "concepts": ["preorder_traversal", "inorder_traversal"],
      "error_patterns": [
        "l3_c1_p3_wrong_node_for_root",
        "l3_c1_p3_wrong_side_of_binary_tree",
        "l3_c1_p3_generic_mistake",
        "l3_c1_p3_generic_reply"
      ]
    },
    "l3_c2_p1": {
      "description": "Find the max depth of a Binary Tree and return it.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "maxdepth_tc_01_empty",
          "input": "1-N",
          "expected_output": "0",
          "fail_node_id": "node_maxdepth_empty_tree"
        },
        {
          "id": "maxdepth_tc_02_single",
          "input": "1-N",
          "expected_output": "0",
          "fail_node_id": "node_maxdepth_single_node"
        },
        {
          "id": "maxdepth_tc_03_two_levels",
          "input": "1,2,3-N,L,R",
          "expected_output": "1",
          "fail_node_id": "node_maxdepth_basic_height"
        },
        {
          "id": "maxdepth_tc_04_left_skewed",
          "input": "1,2,3,4-N,L,LL,LLL",
          "expected_output": "3",
          "fail_node_id": "node_maxdepth_skewed_left"
        },
        {
          "id": "maxdepth_tc_05_right_skewed",
          "input": "1,2,3,4-N,R,RR,RRR",
          "expected_output": "3",
          "fail_node_id": "node_maxdepth_skewed_right"
        },
        {
          "id": "maxdepth_tc_06_unbalanced_deeper_left",
          "input": "1,2,3,4,5-N,L,R,LL,LLL",
          "expected_output": "3",
          "fail_node_id": "node_maxdepth_unbalanced_tree"
        },
        {
          "id": "maxdepth_tc_07_sparse_with_nulls",
          "input": "1,2,3,4,5-N,L,R,LR,RL",
          "expected_output": "2",
          "fail_node_id": "node_maxdepth_null_children_handling"
        },
        {
          "id": "maxdepth_tc_08_complete_three_levels",
          "input": "1,2,3,4,5,6,7-N,L,R,LL,LR,RL,RR",
          "expected_output": "2",
          "fail_node_id": "node_maxdepth_complete_tree"
        },
        {
          "id": "maxdepth_tc_09_zigzag_chain",
          "input": "1,2,3,4,5-N,L,LR,LRL,LRLR",
          "expected_output": "4",
          "fail_node_id": "node_maxdepth_zigzag_structure"
        }
      ]
    },

    "l3_c2_p2": {
      "type": "puzzle",
      "description": "Perform level-order traversal (BFS) on the binary tree using a queue. Use the buttons to dequeue into cur, print cur.item, and enqueue cur's children to match the expected output.",
      "tests_concepts": [
        "level_order_traversal_bfs",
        "queue_fifo",
        "dequeue_sets_cur",
        "enqueue_children_left_then_right",
        "null_child_handling"
      ],
      "error_patterns": [
        "print_before_dequeue_cur_is_null",
        "enqueue_right_before_left_wrong_order",
        "forget_enqueue_one_child",
        "enqueue_null_child_or_no_null_check",
        "treat_queue_like_stack_lifo",
        "dequeue_too_many_times_skips_nodes",
        "dequeue_when_queue_is_empty"
      ]
    },
    "l3_c2_p3": {
      "type": "puzzle",
      "description": "Search for the node with the target value by choosing left or right.",
      "error_patterns": [
        "choosing_a_smaller_value_than_target_value",
        "choosing_a_larger_value_than_target_value"
      ]
    },
    "l4_c1_p1_q1": {
      "description": "Given L = [8,4,5] and Relics = [1,2,6,9,4,3], how many item comparisons of the form (Q.item == X) are made by subset(L, Relics)?",
      "type": "scroll_mcq",
      "correct_answer": "17",
      "option_to_concept_node": {
        "10": "node_q1_counts_only_successful_searches",
        "6": "node_q1_stops_after_first_found_instead_of_scan",
        "3": "node_q1_counts_only_elements_in_L"
      }
    },
    "l4_c1_p1_q2": {
      "description": "Let R denote the Relics list. Based on the subset(L, R) and element(X, Q) code, when will the worst case happen?",
      "type": "scroll_mcq",
      "correct_answer": "opt3",
      "option_to_concept_node": {
        "opt1": "node_q2_wrong_thinks_missing_early_is_worst",
        "opt2": "node_q2_wrong_ignores_final_failed_search_cost",
        "opt4": "node_q2_wrong_thinks_all_present_at_end_is_worst"
      }
    },
    "l4_c1_p1_q3": {
      "description": "Let O denote the Observed list and R denote the Relics list. Using the given subset(O, R) and element(X, Q) code, what is the worst-case running time of subset as a function of |O| and |R|?",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "node_q3_wrong_thinks_only_R_matters",
        "opt2": "node_q3_wrong_thinks_only_O_matters",
        "opt3": "node_q3_wrong_add_instead_of_multiply"
      }
    },
    "l4_c1_p2_q1": {
      "description": "Documents are sealed according to the function Sealer(N) below. How many times is Seal() called when N = 8?",
      "type": "scroll_mcq",
      "correct_answer": "8",
      "option_to_concept_node": {
        "6": "node_p2q1_wrong_counts_outer_only_or_off_by_one",
        "12": "node_p2q1_wrong_multiplies_logs_or_assumes_full_inner_each_time",
        "15": "node_p2q1_wrong_assumes_quadratic_or_linear_times_linear"
      }
    },
    "l4_c1_p2_q2": {
      "description": "In the function Sealer(N), how many iterations does the inner loop (controlled by k) run in terms of N? (log₂ means log base 2.)",
      "type": "scroll_mcq",
      "correct_answer": "opt1",
      "option_to_concept_node": {
        "opt2": "node_p2q2_wrong_missing_plus_one",
        "opt3": "node_p2q2_wrong_logN_base_confusion",
        "opt4": "node_p2q2_wrong_forgets_initial_iteration"
      }
    },
    "l4_c1_p2_q3": {
      "description": "In the function Sealer(N), how many iterations does the outer loop (controlled by j) run in terms of N? (log₃ means log base 3.)",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "node_p2q3_wrong_base_confusion_log2",
        "opt2": "node_p2q3_wrong_unspecified_log_base",
        "opt3": "node_p2q3_wrong_missing_plus_one"
      }
    },
    "l4_c1_p2_q4": {
      "description": "For Sealer(N), find the time complexity in Big-O notation in terms of N. (Hint: inner loop has log₂(N) iterations and outer loop has log₃(N) iterations.)",
      "type": "scroll_mcq",
      "correct_answer": "opt3",
      "option_to_concept_node": {
        "opt1": "node_p2q4_wrong_thinks_linear_N",
        "opt2": "node_p2q4_wrong_collapses_logs_to_single_log",
        "opt4": "node_p2q4_wrong_uses_log_of_N_squared_instead_of_product"
      }
    },
    "l4_c1_p3_q1": {
      "description": "Given the recursive function Book(N), how many times is Read() executed when starting with N = 3?",
      "type": "scroll_mcq",
      "correct_answer": "11",
      "option_to_concept_node": {
        "7": "node_l4c1p3q1_wrong_counts_only_top_level",
        "13": "node_l4c1p3q1_wrong_double_counts_levels",
        "14": "node_l4c1p3q1_wrong_assumes_full_binary_without_linear_term"
      }
    },
    "l4_c1_p3_q2": {
      "description": "Let W(N) denote the number of Read() calls in Book(N). Which recurrence correctly represents W(N)?",
      "type": "scroll_mcq",
      "correct_answer": "opt4",
      "option_to_concept_node": {
        "opt1": "node_l4c1p3q2_wrong_single_recursive_call",
        "opt2": "node_l4c1p3q2_wrong_fibonacci_assumption",
        "opt3": "node_l4c1p3q2_wrong_missing_linear_term"
      }
    },
    "l4_c1_p3_q3": {
      "description": "For the recursive function Book(N), what is the time complexity in Big-O notation?",
      "type": "scroll_mcq",
      "correct_answer": "opt1",
      "option_to_concept_node": {
        "opt2": "node_l4c1p3q3_wrong_thinks_quadratic",
        "opt3": "node_l4c1p3q3_wrong_thinks_linear",
        "opt4": "node_l4c1p3q3_wrong_thinks_factorial"
      }
    },
    "l4_c1_p4": {
      "description": "Find the minimal element in a cyclically (rotated) sorted sequence in O(log n). The input may contain duplicates. m and n are the indices of the first and last elements respectively.",
      "type": "code_function",
      "test_cases": [
        {
          "id": "min_tc_01_sorted_no_rotation",
          "input": "1,2,3,4,5",
          "expected_output": "1",
          "fail_node_id": "node_min_already_sorted_segment"
        },
        {
          "id": "min_tc_02_simple_rotation",
          "input": "4,5,1,2,3",
          "expected_output": "1",
          "fail_node_id": "node_min_rotation_binary_search"
        },
        {
          "id": "min_tc_03_single_element",
          "input": "7",
          "expected_output": "7",
          "fail_node_id": "node_min_single_element"
        },
        {
          "id": "min_tc_04_two_elements_rotated",
          "input": "2,1",
          "expected_output": "1",
          "fail_node_id": "node_min_boundary_two_elements"
        },
        {
          "id": "min_tc_05_duplicates_not_rotated",
          "input": "2,2,2,2",
          "expected_output": "2",
          "fail_node_id": "node_min_duplicates_equal_values"
        },
        {
          "id": "min_tc_06_duplicates_rotated_tricky",
          "input": "4,5,2,3,4",
          "expected_output": "2",
          "fail_node_id": "node_min_duplicates_break_sorted_check"
        },
        {
          "id": "min_tc_07_duplicates_with_pivot",
          "input": "3,3,3,1,2,3",
          "expected_output": "1",
          "fail_node_id": "node_min_duplicates_shrink_high"
        },
        {
          "id": "min_tc_08_negative_values_rotated",
          "input": "0,1,2,-3,-2,-1",
          "expected_output": "-3",
          "fail_node_id": "node_min_handle_negatives"
        }
      ]
    },
    "l5_c1_p1": {
      "type": "puzzle",
      "description": "Return the books to the correct shelves so that each row’s load factor matches its target. A row’s load factor is α = n / m, where n is the total number of books placed in that row and m is the number of shelves in that row.",
      "tests_concepts": [
        "load_factor_n_over_m",
        "m_is_number_of_shelves_fixed",
        "required_n_equals_target_times_m",
        "row_underfilled_vs_overfilled",
        "integer_count_matches_target"
      ],
      "error_patterns": [
        "bookreturn_n_over_m_definition",
        "bookreturn_m_is_shelves_fixed",
        "bookreturn_required_n_equals_target_times_m",
        "bookreturn_row_underfilled",
        "bookreturn_row_overfilled"
      ]
    },
    "l5_c1_p2": {
      "type": "puzzle",
      "description": "Drag and drop books (keys) into the highlighted shelf row to create the required hash table scenario under Open Addressing + Linear Probing. Colors are randomized; only the letter (key) matters. Hover 'Evaluate' to see which row is graded. After arranging correctly, answer 1 MCQ about the average insertion cost at load factor 0.5.",
      "tests_concepts": [
        "hash_table_open_addressing",
        "linear_probing",
        "collision_vs_no_collision",
        "best_case_no_probing",
        "average_case_some_probing",
        "worst_case_primary_clustering",
        "hash_output_not_unique"
      ],
      "error_patterns": [
        "l5_hash_unique_key_implies_unique_hash",
        "l5_hash_visual_spacing_affects_hashing",
        "l5_hash_best_case_means_spread_out_visually",
        "l5_hash_confuse_row_highlight",
        "l5_hash_overfill_or_underfill_solution_row"
      ]
    },
    "l6_c1_p1": {
      "description": "Read the trie and input the words that exist in it by dragging and dropping the correct words onto the device.",
      "type": "puzzle",
      "concepts": ["trie", "prefix_tree", "tree_traversal", "string_matching"],
      "error_patterns": [
        "l6_c1_p1_trie_prefix_only_not_word",
        "l6_c1_p1_trie_wrong_branch_choice",
        "l6_c1_p1_trie_missing_character_step",
        "l6_c1_p1_trie_extra_character_step",
        "l6_c1_p1_trie_confuse_similar_words",
        "l6_c1_p1_trie_visual_guessing"
      ]
    }
  },

  "graph_nodes": {
    "node_evens_core": {
      "hint_text": "Your odds and evens are not ending up in the right halves. First keep all odd numbers in their original order, then all even numbers in their original order.",
      "related_concept": "Linked Lists"
    },
    "node_evens_all_even": {
      "hint_text": "When every value is even, moving them to the back should not change the list at all.",
      "related_concept": "Edge Cases"
    },
    "node_evens_all_odd": {
      "hint_text": "If there are no even numbers, the list should remain exactly the same after your function.",
      "related_concept": "Edge Cases"
    },
    "node_evens_stability": {
      "hint_text": "Be careful not to shuffle the order of odds among themselves or evens among themselves when you move nodes around.",
      "related_concept": "Pointer Manipulation"
    },

    "node_max_not_front": {
      "hint_text": "After your function runs, the largest value in the list should be the very first node.",
      "related_concept": "Linked Lists"
    },
    "node_max_already_front": {
      "hint_text": "If the maximum value is already at the head, your function should not duplicate nodes or break the list.",
      "related_concept": "Edge Cases"
    },
    "node_max_all_equal": {
      "hint_text": "When all values are the same, there is no real 'maximum' to move. The list should look unchanged.",
      "related_concept": "Edge Cases"
    },
    "node_max_multiple": {
      "hint_text": "When there are several equal maximum values, usually only the first one is moved to the front. Make sure you don't lose or reorder the others incorrectly.",
      "related_concept": "Pointer Manipulation"
    },

    "node_dups_core": {
      "hint_text": "You should remove consecutive duplicates so each value appears once. Make sure you keep skipping nodes while the next value is the same.",
      "related_concept": "Linked Lists"
    },
    "node_dups_nochange": {
      "hint_text": "If there are no duplicates in the list, your function should leave it completely unchanged.",
      "related_concept": "Edge Cases"
    },
    "node_dups_all_same": {
      "hint_text": "When all elements are equal, the final list should contain just a single node with that value.",
      "related_concept": "Edge Cases"
    },
    "node_dups_multiple_blocks": {
      "hint_text": "There can be multiple groups of duplicates. Make sure you correctly collapse every group, not just the first one.",
      "related_concept": "Pointer Manipulation"
    },

    "node_circ_last_next_assignment": {
      "hint_text": "To make the list circular, you must update the last node's next pointer so it points back to the head. Using a comparison operator here will not change the list.",
      "related_concept": "Linked Lists / Assignment vs Comparison"
    },

    "node_erroneous_return_statement": {
      "hint_text": "Please check all the return statements in your code. Make sure you are returning the correct variable representing the head of the list, rather than returning None or another unintended value.",
      "related_concept": "Return Statements"
    },

    "node_func_call_missing_arguments": {
      "hint_text": "Check the definition of half_unlock. Every call to this function should pass the same number of arguments as the parameter list requires.",
      "related_concept": "Function Calls / Parameters"
    },

    "node_wrong_variable_bptr": {
      "hint_text": "When finding b_ptr, use the index that was read for Bptr, not the one for Aptr. Compare how you compute a_ptr and b_ptr.",
      "related_concept": "Variables / Logic Errors"
    },

    "node_main_guard_usage": {
      "hint_text": "Think about how this code will be run in the grading environment. Do you actually need a 'if __name__ == \"__main__\"' block here, or should the judge call your functions directly?",
      "related_concept": "Program Structure / Execution Environment"
    },

    "node_circle_same": {
      "hint_text": "Aptr and Bptr must be two different nodes. Choose two distinct points on the circle.",
      "related_concept": "Pointers"
    },
    "node_circle_adjacent": {
      "hint_text": "Aptr and Bptr are too close. Look for nodes that are opposite each other on the ring, not neighbours.",
      "related_concept": "Circular Linked Lists"
    },
    "node_circle_wrong_distance": {
      "hint_text": "Try counting how many nodes you move when you walk from Aptr to Bptr. It should be half of the total nodes in the circle.",
      "related_concept": "Circular Linked Lists"
    },
    "node_circle_swapped": {
      "hint_text": "Your distance looks right, but the roles of Aptr and Bptr might be swapped. Try switching which node is Aptr and which is Bptr.",
      "related_concept": "Function Parameters"
    },
    "l2_c1_p1_stack_not_used": {
      "related_concept": "stack_usage",
      "hint_text": "If you just follow the infix order, some operators will appear too early. A stack lets you delay outputting operators until it is their turn."
    },
    "l2_c1_p1_ignore_precedence_add_vs_mult": {
      "related_concept": "operator_precedence",
      "hint_text": "Remember that *, /, and % have higher precedence than + and -. Try first converting 'a + b * c' to postfix."
    },
    "l2_c1_p1_assignment_wrong_position": {
      "related_concept": "infix_to_postfix",
      "hint_text": "In postfix, '=' usually comes after the entire right-hand side expression."
    },
    "l2_c1_p1_random_walk": {
      "related_concept": "general",
      "hint_text": "Try breaking the expression into smaller parts and converting them one by one."
    },
    "l2_c1_p2_stack_not_used": {
      "related_concept": "stack_usage",
      "hint_text": "If you output operators as soon as you see them, <<, >> or && may appear too early. Use a stack so that higher-precedence parts are delayed until it is their turn."
    },

    "l2_c1_p2_ignore_precedence_add_vs_shift": {
      "related_concept": "operator_precedence",
      "hint_text": "Remember that + has higher precedence than << and >>. The sum d + e should be formed first, then used in the right-shift with c."
    },

    "l2_c1_p2_ignore_precedence_shift_vs_and": {
      "related_concept": "operator_precedence",
      "hint_text": "Shifts (<<, >>) have higher precedence than logical &&. Treat a << b and c >> (d + e) as two complete pieces before applying && between them."
    },

    "l2_c1_p2_assignment_wrong_position": {
      "related_concept": "infix_to_postfix",
      "hint_text": "In postfix, '=' comes after the entire right-hand side expression. Build the full result of 'a << b && c >> d + e' before placing '='."
    },

    "l2_c1_p2_missing_and_operator": {
      "related_concept": "logical_and",
      "hint_text": "Your path never uses &&. The final expression should combine the left shift and the right shift with a logical AND in between."
    },

    "l2_c1_p2_random_walk": {
      "related_concept": "general",
      "hint_text": "Try to see the expression as two big parts: a << b and c >> (d + e). Convert each part carefully, then join them with && and finally '='."
    },
    "l2_c1_p3_stack_not_used": {
      "related_concept": "stack_usage",
      "hint_text": "If you simply read the postfix expression left-to-right or just reverse it, operators will attach to the wrong operands. For postfix to prefix, use a stack: scan symbols, push operands, and when you see an operator, pop the right number of operands and build a sub-expression."
    },

    "l2_c1_p3_assignment_wrong_position": {
      "related_concept": "assignment_operator",
      "hint_text": "In prefix form, the assignment operator '=' should appear at the very beginning. Its two operands are the variable on the left (x) and the entire right-hand expression built from the rest of the symbols."
    },

    "l2_c1_p3_wrong_grouping_add_vs_shift": {
      "related_concept": "expression_grouping",
      "hint_text": "Treat 'a b c * d % +' as one big sub-expression before combining it with e using '>>'. In prefix, that inner part becomes '+ a % * b c d', which is then shifted with e and finally assigned to x."
    },

    "l2_c1_p3_random_walk": {
      "related_concept": "general",
      "hint_text": "Try simulating the postfix-to-prefix algorithm step by step on paper: start with an empty stack, scan each symbol from left to right, push operands, and when you see an operator, pop operands, build a small prefix fragment, and push it back."
    },
    "l2_c2_p1_never_used_queue": {
      "related_concept": "queue_usage",
      "hint_text": "A stack alone cannot reverse itself. You must transfer items into the queue to reverse their order, then move them back into the stack."
    },
    "l2_c2_p1_rotated_before_transfer": {
      "related_concept": "queue_rotation",
      "hint_text": "Before rotating the queue, make sure all stack items have been moved into the queue. Rotating too early will scramble the intended reversed order."
    },
    "l2_c2_p1_messed_partial_order": {
      "related_concept": "stack_reversal",
      "hint_text": "To reverse the entire stack, all items must be removed from the stack, enqueued in order, and then dequeued back into the stack. A partial reversal will not work."
    },
    "l2_c2_p1_wrong_operation_order": {
      "related_concept": "algorithm_steps",
      "hint_text": "Try following this structure: 1) Pop every item from the stack and enqueue it. 2) Dequeue items back into the stack. This sequence fully reverses the stack."
    },
    "l2_c2_p2_missing_stack": {
      "related_concept": "stack_usage",
      "hint_text": "A queue alone cannot reverse the first k logs. Try moving the first k logs into the stack and then back to the queue so that their order is flipped."
    },

    "l2_c2_p2_touched_tail_segment": {
      "related_concept": "queue_segments",
      "hint_text": "Only the first k logs should be rearranged. If you dequeue or move too many logs, you will disturb the items that are supposed to stay in their original positions."
    },

    "l2_c2_p2_rotated_too_early": {
      "related_concept": "queue_rotation",
      "hint_text": "Rotating the queue (moving head items to the tail) is useful only after the first k logs have been reversed. If you rotate too early, both the front and back segments become scrambled."
    },

    "l2_c2_p2_wrong_operation_order": {
      "related_concept": "algorithm_steps",
      "hint_text": "Think in stages: first move the first k logs from the queue into the stack, then pop them back into the queue, and only after that rotate the queue so the reversed segment moves to the front."
    },

    "l2_c2_p2_random_walk": {
      "related_concept": "general",
      "hint_text": "Break the problem into smaller steps. Use the stack to reverse the first k logs, then use queue operations to rotate the queue until the reversed part is at the front and the rest is unchanged."
    },
    "node_sortstack_core": {
      "hint_text": "Use one temporary stack. Pop from the original stack and insert into the temp stack in sorted position by moving larger items back to the original stack, then push them back.",
      "related_concept": "Stacks"
    },
    "node_sortstack_already_sorted": {
      "hint_text": "If the stack is already in ascending order, your algorithm should not disturb it. Double-check your comparison condition inside the while-loop.",
      "related_concept": "Correctness"
    },
    "node_sortstack_reverse_sorted": {
      "hint_text": "A reverse-sorted stack forces the most moves. Make sure you repeatedly move items between the two stacks until the temp stack remains sorted after each insertion.",
      "related_concept": "Algorithmic Thinking"
    },
    "node_sortstack_duplicates": {
      "hint_text": "Handle equal values carefully. Decide whether your inner loop should move values only when tempTop > current (strict) or >= current (non-strict) so duplicates end up correct.",
      "related_concept": "Edge Cases"
    },
    "node_sortstack_single": {
      "hint_text": "With one element, no operations are needed. If this fails, your function may be popping/pushing incorrectly when the stack becomes empty.",
      "related_concept": "Edge Cases"
    },
    "l3_c1_p1_bt_inorder_root_first": {
      "hint_text": "In-order traversal does not start by clicking the root. You must finish the entire left subtree first, then visit the node, then the right subtree (Left -> Node -> Right).",
      "related_concept": "Traversal Types"
    },
    "l3_c1_p1_bt_inorder_left_not_finished": {
      "hint_text": "You clicked a node before completing everything in its left subtree. In-order is recursive: completely traverse the left subtree before clicking the parent node.",
      "related_concept": "Recursion / Subtrees"
    },
    "l3_c1_p1_bt_inorder_skipped_right_subtree": {
      "hint_text": "After you visit a node, you must traverse its right subtree before moving back up. In-order always follows Left -> Node -> Right.",
      "related_concept": "In-order Rule"
    },
    "l3_c1_p1_bt_inorder_visual_guessing": {
      "hint_text": "Don't click based on screen position. Traversal order depends on the tree structure: left subtree first, then node, then right subtree.",
      "related_concept": "Abstract Data Structures"
    },
    "l3_c1_p1_bt_inorder_bst_sorted_assumption": {
      "hint_text": "In-order traversal is not \"sorted order\" unless it's a BST with values. Focus on the structural rule: Left -> Node -> Right.",
      "related_concept": "Binary Tree vs BST"
    },
    "l3_c1_p1_bt_inorder_random_walk": {
      "hint_text": "Try a consistent method: start from the leftmost node, then work upward applying Left -> Node -> Right at every subtree. Don't guess, instead, trace the next node logically.",
      "related_concept": "Tracing / Strategy"
    },
    "l3_c1_p2_bt_preorder_not_root_first": {
      "hint_text": "Pre-order traversal ALWAYS starts at the root node. The rule is Node -> Left -> Right, so the root must be clicked first.",
      "related_concept": "Traversal Types"
    },
    "l3_c1_p2_bt_preorder_left_skipped": {
      "hint_text": "After visiting a node in pre-order, you must immediately traverse its left subtree before going right.",
      "related_concept": "Pre-order Rule"
    },
    "l3_c1_p2_bt_preorder_right_before_left": {
      "hint_text": "You moved to the right subtree too early. Pre-order traversal always explores the LEFT subtree before the RIGHT subtree.",
      "related_concept": "Left vs Right Subtrees"
    },
    "l3_c1_p2_bt_preorder_visual_guessing": {
      "hint_text": "Don't rely on visual layout. Pre-order traversal depends on tree structure, not screen position: Node -> Left -> Right.",
      "related_concept": "Abstract Data Structures"
    },
    "l3_c1_p2_bt_preorder_subtree_not_finished": {
      "hint_text": "Once you enter a subtree in pre-order, fully traverse it before moving back up. Each subtree follows Node -> Left -> Right recursively.",
      "related_concept": "Recursion / Subtrees"
    },
    "l3_c1_p2_bt_preorder_random_walk": {
      "hint_text": "Use a systematic approach: start at the root, then repeatedly apply Node -> Left -> Right at every subtree. Avoid guessing.",
      "related_concept": "Tracing / Strategy"
    },
    "l3_c1_p3_wrong_node_for_root": {
      "hint_text": "Please check the root node again. The Pre-order traversal always starts with the root node.",
      "related_concept": "Pre-order traversal"
    },
    "l3_c1_p3_wrong_side_of_binary_tree": {
      "hint_text": "Are you sure that node is on the right side of the tree? Check the traversal order again!",
      "related_concept": "Tracing"
    },
    "l3_c1_p3_generic_mistake": {
      "hint_text": "Please check the placement of the nodes again.",
      "related_concept": "Carelessness"
    },
    "l3_c1_p3_generic_reply": {
      "hint_text": "Please ensure that all nodes have been placed in the tree.",
      "related_concept": "Reminder"
    },
    "node_maxdepth_empty_tree": {
      "hint_text": "Remember that a Binary tree could also be an empty tree!",
      "related_concept": "Empty Binary Tree"
    },
    "node_maxdepth_single_node": {
      "hint_text": "Remember that a Binary Tree could also consists of a single node!",
      "related_concept": "Single node Binary Tree"
    },
    "node_maxdepth_basic_height": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_skewed_left": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_skewed_right": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_unbalanced_tree": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_null_children_handling": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_complete_tree": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_zigzag_structure": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "node_maxdepth_ignore_node_values": {
      "hint_text": "You are close! Check your code again!",
      "related_concept": "Wrong logic"
    },
    "l3_c2_p2_print_before_dequeue_cur_is_null": {
      "related_concept": "dequeue_sets_cur",
      "hint_text": "Cur is still null. You need to dequeue a node from the queue before you can print cur.item."
    },
    "l3_c2_p2_enqueue_right_before_left_wrong_order": {
      "related_concept": "enqueue_children_left_then_right",
      "hint_text": "In level-order traversal, enqueue the left child before the right child to preserve the correct order within each level."
    },
    "l3_c2_p2_forget_enqueue_one_child": {
      "related_concept": "level_order_traversal_bfs",
      "hint_text": "If a node has two children, both usually need to be enqueued. Skipping one child will cause missing values in the output."
    },
    "l3_c2_p2_enqueue_null_child_or_no_null_check": {
      "related_concept": "null_child_handling",
      "hint_text": "Only enqueue children that exist. Enqueuing null nodes leads to invalid steps later when dequeuing."
    },
    "l3_c2_p2_treat_queue_like_stack_lifo": {
      "related_concept": "queue_fifo",
      "hint_text": "A queue is FIFO, not LIFO. The first node enqueued should be the first node dequeued—don’t treat it like a stack."
    },
    "l3_c2_p2_dequeue_too_many_times_skips_nodes": {
      "related_concept": "level_order_traversal_bfs",
      "hint_text": "After dequeuing a node, you should process it fully (print it and enqueue its children) before dequeuing again."
    },
    "l3_c2_p2_dequeue_when_queue_is_empty": {
      "related_concept": "empty_queue",
      "hint_text": "Your enqueue is empty, there is nothing to dequeue!"
    },
    "l3_c2_p3_choosing_a_smaller_value_than_target_value": {
      "related_concept": "Arrangement of nodes in Binary Search Tree",
      "hint_text": "In a Binary Search Tree, the left child has a value smaller than the parents value."
    },
    "l3_c2_p3_choosing_a_larger_value_than_target_value": {
      "related_concept": "Arrangement of nodes in Binary Search Tree",
      "hint_text": "In a Binary Search Tree, the right child has a value larger than the parent value."
    },
    "node_min_already_sorted_segment": {
      "hint_text": "If the current search range is already in increasing order, the first element of that range is the minimum. But be careful: with duplicates, equality at the ends can be misleading.",
      "related_concept": "Binary Search"
    },
    "node_min_rotation_binary_search": {
      "hint_text": "Use binary search by comparing the middle element with the rightmost element to decide which half contains the minimum.",
      "related_concept": "Divide and Conquer"
    },
    "node_min_single_element": {
      "hint_text": "If there is only one element in the range, that element must be the minimum.",
      "related_concept": "Edge Cases"
    },
    "node_min_boundary_two_elements": {
      "hint_text": "For two elements, make sure your logic still returns the smaller one even if the array is rotated (e.g., [2,1]).",
      "related_concept": "Boundary Conditions"
    },
    "node_min_duplicates_equal_values": {
      "hint_text": "When many values are identical, comparisons may not tell you which side to search. Your method should still return the correct minimum.",
      "related_concept": "Edge Cases"
    },
    "node_min_duplicates_break_sorted_check": {
      "hint_text": "If the first and last elements are equal, the segment might NOT be fully sorted (e.g., [4,5,2,3,4]). Avoid using a simple 'already sorted' shortcut in this case.",
      "related_concept": "Duplicates in Binary Search"
    },
    "node_min_duplicates_shrink_high": {
      "hint_text": "When array[mid] equals array[high], you can't decide which half is correct—shrink the search range safely (e.g., decrease high by 1) and continue.",
      "related_concept": "Duplicates in Binary Search"
    },
    "node_min_handle_negatives": {
      "hint_text": "The same rotated-array logic works with negative numbers too. Don't assume values are non-negative—only rely on comparisons.",
      "related_concept": "Comparison-Based Algorithms"
    },
    "node_q1_counts_only_successful_searches": {
      "hint_text": "You are undercounting: even when an element is found, element(X, Q) still compares against each earlier node it visited. Count every (Q.item == X) comparison along the path until the match is found (or Q becomes None).",
      "related_concept": "Linked Lists / Counting Comparisons in Linear Search"
    },

    "node_q1_stops_after_first_found_instead_of_scan": {
      "hint_text": "You seem to assume each element() call only needs 1 comparison when it eventually finds the value. But element() may compare against many Relics nodes before it reaches the matching node. Trace where 4 appears in Relics (it’s not at the start).",
      "related_concept": "Tracing Execution / Position of Match in a Linked List"
    },

    "node_q1_counts_only_elements_in_L": {
      "hint_text": "You counted only the number of items in L (or only the outer loop). But the real work happens inside element(X, Relics), which scans through Relics and performs one (Q.item == X) comparison per node visited.",
      "related_concept": "Nested Traversal / Outer Loop vs Inner Scan"
    },
    "node_q2_wrong_thinks_missing_early_is_worst": {
      "hint_text": "If the first element of L is not in R, subset() stops immediately after one element() call. That usually makes it FAST, not worst-case. Worst-case needs you to spend a lot of time searching before you can stop.",
      "related_concept": "Early Termination / Best vs Worst Case"
    },

    "node_q2_wrong_ignores_final_failed_search_cost": {
      "hint_text": "Having the first |L|-1 elements found near the end of R does cause long searches, but worst-case is even worse when you also do a final full scan that FAILS (the last element of L is not in R), because element() must traverse all of R before returning False.",
      "related_concept": "Worst Case Reasoning / Full Scan on Failure"
    },

    "node_q2_wrong_thinks_all_present_at_end_is_worst": {
      "hint_text": "If L forms the last |L| elements of R, then every element of L IS in R, so every element() search will eventually succeed. The worst-case for subset-check typically occurs when many searches are long AND the final one fails only after scanning all of R.",
      "related_concept": "Worst Case Conditions / Success vs Failure Search"
    },
    "node_q3_wrong_thinks_only_R_matters": {
      "hint_text": "Θ(|R|) would only be true if subset() called element() a constant number of times. But subset() loops over O, and each iteration may scan through many nodes of R. So the total work depends on BOTH |O| and |R|.",
      "related_concept": "Worst-Case Complexity / Nested Traversals"
    },

    "node_q3_wrong_thinks_only_O_matters": {
      "hint_text": "Θ(|O|) would only make sense if element() were O(1). But element() is a linear scan of R (it may compare against every node if the item is at the end or not present). That inner scan dominates the cost.",
      "related_concept": "Linear Search in Linked Lists / Inner Loop Cost"
    },

    "node_q3_wrong_add_instead_of_multiply": {
      "hint_text": "Θ(|O| + |R|) is typical when you traverse two lists once each. Here, you traverse O, and for EACH item in O you may traverse R again via element(). That’s repeated work, so the costs multiply in the worst case.",
      "related_concept": "Nested Loops / Additive vs Multiplicative Growth"
    },
    "node_p2q1_wrong_counts_outer_only_or_off_by_one": {
      "hint_text": "Don’t count only the outer loop. The number of Seal() calls comes from the inner loop. For each outer-loop round, k starts at 1 and doubles (1, 2, 4, 8, ...), calling Seal() once per value of k while k <= N.",
      "related_concept": "Tracing Nested Loops / Geometric Progression"
    },

    "node_p2q1_wrong_multiplies_logs_or_assumes_full_inner_each_time": {
      "hint_text": "Be careful not to multiply incorrectly. First, list how many times the OUTER loop runs when j multiplies by 3 (j = 1, 3, 9, ...). Then separately count how many Seal() calls happen per outer iteration when k doubles (k = 1, 2, 4, 8, ...).",
      "related_concept": "Nested Loops / Counting Iterations Precisely"
    },

    "node_p2q1_wrong_assumes_quadratic_or_linear_times_linear": {
      "hint_text": "This is not a 'k++' inner loop. Since k doubles each time, the inner loop runs in logarithmic steps, not N steps. Try writing down the exact k sequence for N=8 to avoid overcounting.",
      "related_concept": "Logarithmic Loops / Doubling Pattern"
    },
    "node_p2q2_wrong_missing_plus_one": {
      "hint_text": "The loop starts with k = 1 and continues while k <= N. Since k doubles each time (1, 2, 4, 8, ...), you must count the initial value k = 1 as an iteration. That’s why it is not just log₂(N), but floor(log₂(N)) + 1.",
      "related_concept": "Logarithmic Loops / Off-by-One Counting"
    },

    "node_p2q2_wrong_logN_base_confusion": {
      "hint_text": "Be careful with notation. The loop doubles k each time (k *= 2), so the growth is base 2. The number of times you can double 1 before exceeding N is related to log₂(N), not log(N) with an unspecified base.",
      "related_concept": "Logarithms / Base Interpretation"
    },

    "node_p2q2_wrong_forgets_initial_iteration": {
      "hint_text": "List the actual values of k for a small N (e.g., N = 8): 1, 2, 4, 8. Notice there are 4 iterations. Since log₂(8) = 3, you need one extra count for the starting value k = 1.",
      "related_concept": "Tracing Geometric Progression / Boundary Conditions"
    },
    "node_p2q3_wrong_base_confusion_log2": {
      "hint_text": "The outer loop multiplies j by 3 each time (j *= 3), not by 2. So the number of times j can grow from 1 to exceed N is determined by powers of 3, which relates to log₃(N), not log₂(N).",
      "related_concept": "Logarithms / Matching Base to Growth Factor"
    },

    "node_p2q3_wrong_unspecified_log_base": {
      "hint_text": "Be precise about the base. Since j grows as 1, 3, 9, 27, ... (powers of 3), the correct logarithm must be base 3. Using logN without specifying base can hide this key detail.",
      "related_concept": "Logarithms / Base Interpretation"
    },

    "node_p2q3_wrong_missing_plus_one": {
      "hint_text": "List the actual values of j for a small N (e.g., N = 9): 1, 3, 9. That’s 3 iterations. Since log₃(9) = 2, you need to add 1 to count the initial value j = 1. That’s why it’s floor(log₃(N)) + 1.",
      "related_concept": "Geometric Progression / Off-by-One Counting"
    },
    "node_p2q4_wrong_thinks_linear_N": {
      "hint_text": "Neither loop increases by +1. The inner loop doubles k (k *= 2) and the outer loop triples j (j *= 3), so both loops run logarithmically, not linearly. The total cannot be O(N).",
      "related_concept": "Logarithmic Loops / Growth Factors"
    },

    "node_p2q4_wrong_collapses_logs_to_single_log": {
      "hint_text": "The loops are nested, so you multiply their iteration counts: (log₂(N)) * (log₃(N)). You should not simplify this into just O(log N) because both logs contribute multiplicatively.",
      "related_concept": "Nested Loops / Multiplying Costs"
    },

    "node_p2q4_wrong_uses_log_of_N_squared_instead_of_product": {
      "hint_text": "Be careful with log identities: log(N^2) means 2·log(N), which is still O(log N). Here you have (log₂(N))·(log₃(N)), which grows like (log N)^2 up to constant factors (change of base).",
      "related_concept": "Logarithm Rules / (log N)^2 vs log(N^2)"
    },
    "node_l4c1p3q1_wrong_counts_only_top_level": {
      "hint_text": "You may be counting only the first call’s for-loop (Read() done N times). But after that, Book(N) calls Book(N-1) twice, and each of those calls also performs its own reads and recursive calls.",
      "related_concept": "Recursion Tree / Expanding Recursive Calls"
    },

    "node_l4c1p3q1_wrong_double_counts_levels": {
      "hint_text": "Be careful not to overcount. Each Book(N) call contributes exactly N Read() calls, then spawns two Book(N-1) calls. Try expanding from N=3 → two calls at N=2 → four calls at N=1, and sum the reads per level.",
      "related_concept": "Tracing Recursion / Summing Per-Level Work"
    },

    "node_l4c1p3q1_wrong_assumes_full_binary_without_linear_term": {
      "hint_text": "This recursion is not only about the number of nodes in a binary tree. Every node also does a for-loop with N reads at that level. Include both the branching (two calls) and the linear work done at each call.",
      "related_concept": "Recurrence Relations / Combining Linear and Recursive Work"
    },
    "node_l4c1p3q2_wrong_single_recursive_call": {
      "hint_text": "Book(N) makes TWO recursive calls to Book(N-1), not one. So W(N) must include 2·W(N-1), not just W(N-1). Also remember to include the N reads from the for-loop.",
      "related_concept": "Recurrence Relations / Counting Recursive Calls"
    },

    "node_l4c1p3q2_wrong_fibonacci_assumption": {
      "hint_text": "This is not a Fibonacci-style recursion. Both recursive calls are Book(N-1), not Book(N-1) and Book(N-2). Carefully match the recurrence to the actual recursive structure.",
      "related_concept": "Recursion Structure / Matching Code to Recurrence"
    },

    "node_l4c1p3q2_wrong_missing_linear_term": {
      "hint_text": "Each call to Book(N) performs N Read() operations before making the recursive calls. So besides the 2·W(N-1) part, you must also add the linear term N.",
      "related_concept": "Recurrence Relations / Combining Recursive and Linear Work"
    },
    "node_l4c1p3q3_wrong_thinks_quadratic": {
      "hint_text": "The function makes two recursive calls at each level: Book(N-1) and Book(N-1). That branching causes exponential growth in the number of calls. A quadratic time complexity (O(N^2)) grows much slower than this recursion tree.",
      "related_concept": "Recursion Tree / Exponential Growth"
    },

    "node_l4c1p3q3_wrong_thinks_linear": {
      "hint_text": "Although each call performs N Read() operations, the key factor is the two recursive calls to Book(N-1). This creates a binary recursion tree, which grows exponentially, not linearly.",
      "related_concept": "Recurrence Relations / Dominant Term"
    },

    "node_l4c1p3q3_wrong_thinks_factorial": {
      "hint_text": "Factorial time usually appears when each level branches into N, N-1, N-2, ... calls. Here, each level makes exactly two recursive calls. That leads to exponential growth like 2^N, not N!.",
      "related_concept": "Recursion Patterns / Comparing Growth Rates"
    },
    "l5_c1_p1_bookreturn_n_over_m_definition": {
      "related_concept": "load_factor_n_over_m",
      "hint_text": "Load factor is α = n / m. Here, n is the total number of books placed in the row, and m is the number of shelves in that row."
    },
    "l5_c1_p1_bookreturn_m_is_shelves_fixed": {
      "related_concept": "m_is_number_of_shelves_fixed",
      "hint_text": "m is fixed by the row layout: it’s the number of shelves in that row. You can only change α by changing n (how many books are placed)."
    },
    "l5_c1_p1_bookreturn_required_n_equals_target_times_m": {
      "related_concept": "required_n_equals_target_times_m",
      "hint_text": "Convert the target into a required book count: n = α × m. Multiply the target load factor by the number of shelves in the row to get exactly how many books that row must contain."
    },
    "l5_c1_p1_bookreturn_row_underfilled": {
      "related_concept": "row_underfilled_vs_overfilled",
      "hint_text": "This row is underfilled: it has too few books for its target. Add more books into this row until n matches the required count."
    },
    "l5_c1_p1_bookreturn_row_overfilled": {
      "related_concept": "row_underfilled_vs_overfilled",
      "hint_text": "This row is overfilled: it has too many books for its target. Remove or move some books out until n matches the required count."
    },
    "l5_c1_p2_row_underfilled": {
      "related_concept": "hashing",
      "hint_text": "All slots have to be filled. You have too little books on the bookshelf."
    },
    "l5_c1_p2_best_case_no_probing": {
      "related_concept": "hint",
      "hint_text": "Best-case for linear probing means: every key lands in its first hashed slot with no collisions, so no probing happens."
    },
    "l5_c1_p2_worst_case_primary_clustering": {
      "related_concept": "hint",
      "hint_text": "Worst-case happens when many keys collide and form one long contiguous cluster. Linear probing then checks many slots before finding an empty one."
    },
    "l5_c1_p2_generic_reply": {
      "related_concept": "Carelessness",
      "hint_text": "Please check your arrangement again."
    }
  },
  "l6_c1_p1_trie_prefix_only_not_word": {
    "hint_text": "A path in a trie is not automatically a valid word. The word only counts if the path ends exactly at a terminal (end-of-word) node. If you stop too early, it’s only a prefix.",
    "related_concept": "Prefix vs Complete Word"
  },
  "l6_c1_p1_trie_wrong_branch_choice": {
    "hint_text": "After choosing the first letter, you must follow the correct child branch for the next character. If the next character is not available as a child node, that word cannot be formed.",
    "related_concept": "Branching in Tries"
  },
  "l6_c1_p1_trie_missing_character_step": {
    "hint_text": "You skipped a character. In a trie, each step down the tree represents exactly one next letter in the word—no letters can be jumped over.",
    "related_concept": "Character-by-Character Traversal"
  },
  "l6_c1_p1_trie_extra_character_step": {
    "hint_text": "You added an extra letter beyond what the trie supports. Even if a shorter word exists, a longer word is only valid if the trie continues with matching child nodes and ends at a terminal node.",
    "related_concept": "Exact Path Matching"
  },
  "l6_c1_p1_trie_confuse_similar_words": {
    "hint_text": "Be careful with similar-looking options (e.g., 'rat' vs 'rap' vs 'rapt'). Check the trie path letter by letter, and confirm the terminal node at the exact final letter.",
    "related_concept": "Disambiguating Similar Prefixes"
  },
  "l6_c1_p1_trie_visual_guessing": {
    "hint_text": "Don’t choose words based on what 'looks' likely. Trace the trie properly: start at the root, follow each letter down, and only accept the word if you land on a terminal node at the end.",
    "related_concept": "Systematic Tracing Strategy"
  }
}
